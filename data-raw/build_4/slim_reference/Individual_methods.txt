– (logical)containsMutations(object<Mutation> mutations)
Returns a logical vector indicating whether each of the mutations in mutations is present in the
individual (in either of its genomes); each element in the returned vector indicates whether the
corresponding mutation is present (T) or absent (F). This method is provided for speed; it is much
faster than the corresponding Eidos code.
– (integer$)countOfMutationsOfType(io<MutationType>$ mutType)
Returns the number of mutations that are of the type specified by mutType, out of all of the mutations
in the individual (in both of its genomes; a mutation that is present in both genomes counts twice). If
you need a vector of the matching Mutation objects, rather than just a count, you should probably
use uniqueMutationsOfType(). This method is provided for speed; it is much faster than the
corresponding Eidos code.
– (float)relatedness(object<Individual> individuals)
Returns a vector containing the degrees of relatedness between the receiver and each of the
individuals in individuals. The relatedness between A and B is always 1.0 if A and B are actually
the same individual; this facility works even if SLiM’s optional pedigree tracking is not enabled (in
which case all other relatedness values will be 0.0). Otherwise, if pedigree tracking is turned on with
initializeSLiMOptions(keepPedigrees=T), this method will use the pedigree information
described in section 24.7.1 to construct a relatedness estimate.
More specifically, this method uses all available pedigree information from the grandparental and
parental pedigree records of A and B to compute an estimate of the degree of consanguinity between A
and B. Siblings have a relatedness of 0.5, as do parents to their children and vice versa; cousins have
a relatedness of 0.125; and so forth. If, according to the pedigree information available, A and B have
no blood relationship, the value returned is 0.0. Note that the value returned by relatedness() is
what is called the “coefficient of relationship” between the two individuals (Wright, 1922; https://
doi.org/10.1086/279872), and ranges from 0.0 to 1.0.
There is another commonly used metric of relatedness, called the “kinship coefficient”, that reflects
the probability of identity by descent between two individuals A and B. In general, it is approximately
equal to one-half of the coefficient of relationship; if an approximate estimate of the kinship
coefficient is acceptable, especially in models in which individuals are expected to be outbred, you
can simply divide relatedness() by two. However, it should be noted that Wright’s coefficient of
relationship is not a measure of the probability of identity by descent, and so it is not exactly double
the kinship coefficient; they actually measure different things. More precisely, the relationship
between them is r = 2φ/sqrt((1+fA)(1+fB)), where r is Wright’s coefficient of relatedness, φ is the kinship
coefficient, and fA and fB are the inbreeding coefficients of A and B respectively.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 652
Note that this relatedness is simply pedigree-based relatedness, and does not necessarily correspond
to genetic relatedness, because of the effects of factors like assortment and recombination. If a metric
of actual genetic relatedness is desired, tree-sequence recording can be used after simulation is
complete, to compute the exact genetic relatedness between individuals based upon the complete
ancestry tree (a topic which is beyond the scope of this manual). Actual genetic relatedness cannot
presently be calculated during a simulation run; the information is implicitly contained in the
recorded tree-sequence tables, but calculating it is too computationally expensive to be reasonable.
This method makes a couple of assumptions. One assumption is that the grandparents (or the parents,
if grandparental information is not available) are themselves unrelated and that they are not inbred;
this assumption is necessary because we have no information about their parentage, since SLiM’s
pedigree tracking information only goes back two generations. Be aware that in a model where
inbreeding or selfing occurs at all (including “incidental selfing”, where a hermaphroditic individual
happens to choose itself as a mate), some level of “background relatedness” will be present and this
assumption will be violated. In such circumstances, relatedness() will therefore tend to
underestimate the degree of relatedness between individuals, and the greater the degree of inbreeding,
the greater the underestimation will be. If inbreeding is allowed in a model – and particularly if it is
common – the results of relatedness() should therefore not be taken as an estimate of absolute
relatedness, but can still be useful as an estimate of relative relatedness (indicating that, say, A appears
from the information available to be more closely related to B than it is to C).
A second assumption is that, in nonWF models, addRecombinant() is not being used, since the
pedigree relationships involved are then too complex to trace. Indeed, addRecombinant() does not
record pedigree information at all, for this reason, and so the relatedness of individuals produced by
addRecombinant() will be 0.0.
+ (void)setSpatialPosition(float position)
Sets the spatial position of the individual (as accessed through the spatialPosition property). The
length of position (the number of coordinates in the spatial position of an individual) depends upon
the spatial dimensionality declared with initializeSLiMOptions(). If the spatial dimensionality is
zero (as it is by default), it is an error to call this method. The elements of position are set into the
values of the x, y, and z properties (if those properties are encompassed by the spatial dimensionality
of the simulation). In other words, if the declared dimensionality is "xy", calling
individual.setSpatialPosition(c(1.0, 0.5)) property is equivalent to individual.x = 1.0;
individual.y = 0.5; individual.z is not set (even if a third value is supplied in position) since
it is not encompassed by the simulation’s dimensionality in this example.
Note that this is an Eidos class method, somewhat unusually, which allows it to work in a special way
when called on a vector of individuals. When the target vector of individuals is non-singleton, this
method can do one of two things. If position contains just a single point (i.e., is equal in length to
the spatial dimensionality of the model), the spatial position of all of the target individuals will be set
to the given point. Alternatively, if position contains one point per target individual (i.e., is equal in
length to the number of individuals multiplied by the spatial dimensionality of the model), the spatial
position of each target individual will be set to the corresponding point from position (where the
point data is concatenated, not interleaved, just as it would be returned by accessing the
spatialPosition property on the vector of target individuals). Calling this method with a position
vector of any other length is an error.
– (float$)sumOfMutationsOfType(io<MutationType>$ mutType)
Returns the sum of the selection coefficients of all mutations that are of the type specified by mutType,
out of all of the mutations in the genomes of the individual. This is often useful in models that use a
particular mutation type to represent QTLs with additive effects; in that context,
sumOfMutationsOfType() will provide the sum of the additive effects of the QTLs for the given
mutation type. This method is provided for speed; it is much faster than the corresponding Eidos code.
Note that this method also exists on Genome, for cases in which the sum for just one genome is
desired.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 653
– (object<Mutation>)uniqueMutationsOfType(io<MutationType>$ mutType)
Returns an object vector of all the mutations that are of the type specified by mutType, out of all of
the mutations in the individual. Mutations present in both genomes will occur only once in the result
of this method, and the mutations will be given in sorted order by position, so this method is similar
to sortBy(unique(individual.genomes.mutationsOfType(mutType)), "position"). It is not
identical to that call, only because if multiple mutations exist at the exact same position, they may be
sorted differently by this method than they would be by sortBy(). If you just need a count of the
matching Mutation objects, rather than a vector of the matches, use -countOfMutationsOfType().
This method is provided for speed; it is much faster than the corresponding Eidos code. Indeed, it is
faster than just individual.genomes.mutationsOfType(mutType), and gives uniquing and sorting
on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually
needed.
