– (float)clippedIntegral(No<Individual> receivers)
Returns a vector containing the integral of the interaction function as experienced by each of the
individuals in receivers. For each given individual, the interaction function is clipped to the edges
of the spatial bounds of the subpopulation that individual inhabits; the individual’s spatial position
must be within bounds or an error is raised. A periodic boundary will, correctly, not clip the
interaction function. The interaction function is also clipped to the interaction’s maximum distance;
that distance must be less than half of the extent of the spatial bounds in each dimension (so that, for a
given dimension, the interaction function is clipped by the spatial bounds on only one side), otherwise
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 658
an error is raised. Note that for sex-specific interaction types, the sex of the receiver does not matter;
an individual might not actually receive any interactions because of its sex, but it is still considered to
have the same interaction function integral. If receivers is NULL, the maximal integral is returned, as
would be experienced by an individual farther than the maximum distance from any edge. The
evaluate() method must have been previously called for the receiver subpopulation, and positions
saved at evaluation time will be used. If the InteractionType is non-spatial, this method may not be
called.
The computed value of the integral is not exact; it is calculated by an approximate numerical method
designed to be fast, but the error should be fairly small (typically less than 1% from the true value). A
large amount of computation will occur the first time this method is called (perhaps taking more than
a second, depending upon hardware), but subsequent calls should be very fast. This method does not
invoke interaction() callbacks; the calculated integrals are only for the interaction function itself,
and so will not be accurate if interaction() callbacks modify the relationship between distance and
interaction strength. For this reason, the overhead of the first call will not reoccur when individuals
move or when the interaction is re-evaluated; for typical models, the initial overhead will be incurred
only once. The initial overhead will reoccur, however, if the interaction function itself, or the
maximum interaction distance, are changed; frequent change of those parameters may render the
performance of this method unacceptable.
The integral values returned by clippedIntegral() can be useful for computing interaction metrics
that are scaled by the amount of “interaction field” (to coin a term) that is present for a given
individual, producing metrics of interaction density. Notably, the localPopulationDensity()
method automatically incorporates the mechanics of clippedIntegral() into the calculations it
performs; see that method’s documentation for further discussion of this concept. This approach can
also be useful with the interactingNeighborCount() method, provided that the interaction
function is of type "f" (since the neighbor count does not depend upon interaction strength).
– (float)distance(object<Individual>$ receiver, [No<Individual> exerters = NULL])
Returns a vector containing distances between receiver and the individuals in exerters. If
exerters is NULL (the default), then a vector of the distances from receiver to all individuals in its
subpopulation (including itself) is returned; this case may be handled differently internally, for greater
speed, so supplying NULL is preferable to supplying the vector of all individuals in the subpopulation
explicitly. Otherwise, all individuals in exerters must belong to a single subpopulation (but not
necessarily the same subpopulation as receiver). The evaluate() method must have been
previously called for the receiver and exerter subpopulations, and positions saved at evaluation time
will be used. If the InteractionType is non-spatial, this method may not be called.
Importantly, distances are calculated according to the spatiality of the InteractionType (as declared
in initializeInteractionType()), not the dimensionality of the model as a whole (as declared in
initializeSLiMOptions()). The distances returned are therefore the distances that would be used
to calculate interaction strengths. However, distance() will return finite distances for all pairs of
individuals, even if the individuals are non-interacting; the distance() between an individual and
itself will thus be 0. See interactionDistance() for an alternative distance definition.
– (float)distanceFromPoint(float point, object<Individual> exerters)
Returns a vector containing distances between the point given by the spatial coordinates in point,
which may be thought of as the “receiver”, and individuals in exerters. The point vector is
interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if
the interaction type’s spatiality is "xz", for example, then point[0] is assumed to be an x value, and
point[1] is assumed to be a z value. Be careful; this means that in general it is not safe to pass an
individual’s spatialPosition property for point, for example (although it is safe if the spatiality of
the interaction matches the dimensionality of the simulation). A coordinate for a periodic spatial
dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic
bounds are meaningless (pointPeriodic() may be used to ensure this); coordinates for non-periodic
spatial dimensions are not restricted. All individuals in exerters must belong to a single
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 659
subpopulation; the evaluate() method must have been previously called for that subpopulation, and
positions saved at evaluation time will be used. If the InteractionType is non-spatial, this method
may not be called. The vector point must be exactly as long as the spatiality of the
InteractionType.
Importantly, distances are calculated according to the spatiality of the InteractionType (as declared
in initializeInteractionType()) not the dimensionality of the model as a whole (as declared in
initializeSLiMOptions()). The distances are therefore interaction distances: the distances that are
used to calculate interaction strengths.
This method replaces the distanceToPoint() method that existed prior to SLiM 4.
– (object<Individual>)drawByStrength(object<Individual>$ receiver,
[integer$ count = 1], [No<Subpopulation>$ exerterSubpop = NULL])
Returns up to count individuals drawn from exerterSubpop, or if that is NULL (the default), then from
the subpopulation of receiver. The probability of drawing particular individuals is proportional to
the strength of interaction they exert upon receiver. All exerters must belong to a single
subpopulation (but not necessarily the same subpopulation as receiver). The evaluate() method
must have been previously called for the receiver and exerter subpopulations, and positions saved at
evaluation time will be used.
This method may be used with either spatial or non-spatial interactions, but will be more efficient with
spatial interactions that set a short maximum interaction distance. Draws are done with replacement,
so the same individual may be drawn more than once; sometimes using unique() on the result of this
call is therefore desirable. If more than one draw will be needed, it is much more efficient to use a
single call to drawByStrength(), rather than drawing individuals one at a time. Note that if no
individuals exert a non-zero interaction strength upon receiver, the vector returned will be zero-
length; it is important to consider this possibility.
– (void)evaluate(io<Subpopulation> subpops)
Snapshots model state in preparation for the use of the interaction, for the receiver and exerter
subpopulations specified by subpops. The subpopulations may be supplied either as integer IDs, or
as Subpopulation objects. This method will discard all previously cached data for the
subpopulation(s), and will cache the current spatial positions of all individuals they contain (so that
the spatial positions of those individuals may then change without disturbing the state of the
interaction at the moment of evaluation). Particular interaction distances and strengths are not
computed by evaluate(), and interaction() callbacks will not be called in response to this
method; that work is deferred until required to satisfy a query (at which point the tick and cycle
counters may have advanced, so be careful with the tick ranges used in defining interaction()
callbacks).
You must explicitly call evaluate() at an appropriate time in the tick cycle before the interaction is
used, but after any relevant changes have been made to the population. SLiM will invalidate any
existing interactions after any portion of the tick cycle in which new individuals have been born or
existing individuals have died. In a WF model, this occurs just before late() events execute (see the
WF tick cycle diagram in chapter 22), so late() events are often the appropriate place to put
evaluate() calls, but first() or early() events can work too if the interaction is not needed until
that point in the tick cycle anyway. In nonWF models, on the other hand, new offspring are produced
just before early() events and then individuals die just before late() events (see the nonWF tick
cycle diagram in chapter 23), so interactions will be invalidated twice during each tick cycle. This
means that in a nonWF model, an interaction that influences reproduction should usually be
evaluated in a first() event, while an interaction that influences fitness or mortality should usually
be evaluated in an early() event (and an interaction that affects both may need to be evaluated at
both times).
If an interaction is never evaluated for a given subpopulation, it is guaranteed that there will be
essentially no memory or computational overhead associated with the interaction for that
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 660
subpopulation. Furthermore, attempting to query an interaction for a receiver or exerter in a
subpopulation that has not been evaluated is guaranteed to raise an error.
– (integer)interactingNeighborCount(object<Individual> receivers,
[No<Subpopulation>$ exerterSubpop = NULL])
Returns the number of interacting individuals for each individual in receivers, within the maximum
interaction distance according to the distance metric of the InteractionType, from among the
exerters in exerterSubpop (or, if that is NULL, then from among all individuals in the receiver’s
subpopulation). More specifically, this method counts the number of individuals which can exert an
interaction upon each receiver. All of the receivers must belong to a single subpopulation, and all of
the exerters must belong to a single subpopulation, but those two subpopulations do not need to be
the same. The evaluate() method must have been previously called for the receiver and exerter
subpopulations, and positions saved at evaluation time will be used.
This method is similar to nearestInteractingNeighbors() (when passed a large count so as to
guarantee that all interacting individuals are returned), but this method returns only a count of the
interacting individuals, not a vector containing the individuals. This method may also be called in a
vectorized fashion, with a non-singleton vector of individuals, unlike
nearestInteractingNeighbors().
Note that this method uses interaction eligibility as a criterion; it will not count neighbors that cannot
exert an interaction upon a receiver (due to sex-segregation, e.g.). (It also does not count a receiver as
a neighbor of itself.) If a count of all neighbors is desired, rather than just interacting neighbors, use
neighborCount(). If the InteractionType is non-spatial, this method may not be called.
– (float)interactionDistance(object<Individual>$ receiver,
[No<Individual> exerters = NULL])
Returns a vector containing interaction-dependent distances between receiver and individuals in
exerters that exert an interaction strength upon receiver. If exerters is NULL (the default), then a
vector of the interaction-dependent distances from receiver to all individuals in its subpopulation
(including receiver itself) is returned; this case may be handled much more efficiently than if a
vector of all individuals in the subpopulation is explicitly provided. Otherwise, all individuals in
exerters must belong to a single subpopulation (but not necessarily the same subpopulation as
receiver). The evaluate() method must have been previously called for the receiver and exerter
subpopulations, and positions saved at evaluation time will be used. If the InteractionType is non-
spatial, this method may not be called.
Importantly, distances are calculated according to the spatiality of the InteractionType (as declared
in initializeInteractionType()), not the dimensionality of the model as a whole (as declared in
initializeSLiMOptions()). The distances returned are therefore the distances that would be used
to calculate interaction strengths. In addition, interactionDistance() will return INF as the
distance between receiver and any individual which does not exert an interaction upon receiver;
the interactionDistance() between an individual and itself will thus be INF, and likewise for pairs
excluded from interacting by the sex segregation or max distance of the interaction type. See
distance() for an alternative distance definition.
– (float)localPopulationDensity(object<Individual> receivers,
[No<Subpopulation>$ exerterSubpop = NULL])
Returns a vector of the local population density present at the location of each individual in
receivers, which does not need to be a singleton; indeed, it can be a vector of all of the individuals
in a given subpopulation. However, all receivers must be in the same subpopulation. The local
population density is computed from exerters in exerterSubpop, or if that is NULL (the default), then
from the receiver’s subpopulation. The evaluate() method must have been previously called for the
receiver and exerter subpopulations, and positions saved at evaluation time will be used.
Population density is estimated using interaction strengths, effectively doing a kernel density estimate
using the interaction function as the kernel. What is returned is computed as the total interaction
strength present at a given point, divided by the integral of the interaction function around that point
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 661
after clipping by the spatial bounds of the exerter subpopulation (what one might think of as the
amount of “interaction field” around the point). This provides an estimate of local population density,
in units of individuals per unit area, as a weighted average over the area covered by the interaction
function, where the weight of each exerter in the average is the value of the interaction function at that
exerter’s position. This can also be thought of as a measure of the amount of interaction happening
per unit of interaction field in the space surrounding the point.
To calculate the clipped integral of the interaction function, this method uses the same numerical
estimator used by the clippedIntegral() method of InteractionType, and all of the caveats
described for that method apply here also; notably, all individuals must be within spatial bounds, the
maximum interaction distance must be less than half the spatial extent of the subpopulation, and
interaction() callbacks are not used (and so, for this method, are not allowed to be active). See the
documentation for clippedIntegral() for further discussion of the details of these calculations.
To calculate the total interaction strength around the position of a receiver, this method uses the same
machinery as the totalOfNeighborStrengths() method of InteractionType, except that – in
contrast to other InteractionType methods – the interaction strength exerted by the receiver itself is
included in the total (if the exerter subpopulation is the receiver’s own subpopulation). This is because
population density at the location of an individual includes the individual itself. If this is not
desirable, the totalOfNeighborStrengths() method should probably be used.
To see the point of this method, consider a receiver located near the edge of the spatial bounds of its
subpopulation. Some portion of the interaction function that surrounds that receiver falls outside the
spatial bounds of its subpopulation, and will therefore never contain an interacting exerter. If, for
example, interaction strengths are used as a measure of competition, this receiver will therefore have
an advantage, because it will never feel any competition from the portion of its range that falls outside
spatial bounds. However, that portion of its range is presumably also not available to the receiver
itself, for foraging or hunting, in which case this advantage is not biologically realistic, but is instead
just an undesirable “edge effect” artifact. Dividing by the integral of the interaction function, clipped
to the spatial bounds, provides a way to compensate for this edge effect. A nice side effect of using
local population densities instead of total interaction strengths is that the maximum interaction
strength passed to setInteractionFunction() no longer matters; it cancels out when the total
interaction strength is divided by the receiver’s clipped integral. However, the shape of the interaction
function does still matter; it determines the relative weights used for exerters at different distances from
the position of the receiver.
– (object<Individual>)nearestInteractingNeighbors(object<Individual>$ receiver,
[integer$ count = 1], [No<Subpopulation>$ exerterSubpop = NULL])
Returns up to count interacting individuals that are spatially closest to receiver, according to the
distance metric of the InteractionType, from among the exerters in exerterSubpop (or, if that is
NULL, then from among all individuals in the receiver’s subpopulation). More specifically, this method
returns only individuals which can exert an interaction upon the receiver. To obtain all of the
interacting individuals within the maximum interaction distance of individual, simply pass a value
for count that is greater than or equal to the size of the exerter subpopulation. Note that if fewer than
count interacting individuals are within the maximum interaction distance, the vector returned may
be shorter than count, or even zero-length; it is important to check for this possibility even when
requesting a single neighbor. If only the number of interacting individuals is needed, use
interactingNeighborCount() instead. The evaluate() method must have been previously called
for the receiver and exerter subpopulations, and positions saved at evaluation time will be used. If the
InteractionType is non-spatial, this method may not be called.
Note that this method uses interaction eligibility as a criterion; it will not return neighbors that cannot
exert an interaction upon the receiver (due to sex-segregation, e.g.). (It will also never return the
receiver as a neighbor of itself.) To find all neighbors of the receiver, whether they can interact with it
or not, use nearestNeighbors().
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 662
– (object<Individual>)nearestNeighbors(object<Individual>$ receiver,
[integer$ count = 1], [No<Subpopulation>$ exerterSubpop = NULL])
Returns up to count individuals that are spatially closest to individual, according to the distance
metric of the InteractionType, from among the exerters in exerterSubpop (or, if that is NULL, then
from among all individuals in the receiver’s subpopulation). To obtain all of the individuals within the
maximum interaction distance of individual, simply pass a value for count that is greater than or
equal to the size of individual’s subpopulation. Note that if fewer than count individuals are within
the maximum interaction distance, the vector returned may be shorter than count, or even zero-
length; it is important to check for this possibility even when requesting a single neighbor. The
evaluate() method must have been previously called for the receiver and exerter subpopulations,
and positions saved at evaluation time will be used. If the InteractionType is non-spatial, this
method may not be called.
Note that this method does not use interaction eligibility as a criterion; it will return neighbors that
could not interact with the receiver due to sex-segregation. (It will never return the receiver as a
neighbor of itself, however.) To find only neighbors that are eligible to exert an interaction upon the
receiver, use nearestInteractingNeighbors().
– (object<Individual>)nearestNeighborsOfPoint(float point,
io<Subpopulation>$ exerterSubpop, [integer$ count = 1])
Returns up to count individuals in exerterSubpop that are spatially closest to point, according to
the distance metric of the InteractionType. The subpopulation may be supplied either as an
integer ID, or as a Subpopulation object. To obtain all of the individuals within the maximum
interaction distance of point, simply pass a value for count that is greater than or equal to the size of
exerterSubpop. Note that if fewer than count individuals are within the maximum interaction
distance, the vector returned may be shorter than count, or even zero-length; it is important to check
for this possibility even when requesting a single neighbor. The evaluate() method must have been
previously called for exerterSubpop, and positions saved at evaluation time will be used. If the
InteractionType is non-spatial, this method may not be called.
– (integer)neighborCount(object<Individual> receivers,
[No<Subpopulation>$ exerterSubpop = NULL])
Returns the number of neighbors for each individual in receivers, within the maximum interaction
distance according to the distance metric of the InteractionType, from among the individuals in
exerterSubpop (or, if that is NULL, then from among all individuals in the receiver’s subpopulation).
All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a
single subpopulation, but those two subpopulations do not need to be the same. The evaluate()
method must have been previously called for the receiver and exerter subpopulations, and positions
saved at evaluation time will be used.
This method is similar to nearestNeighbors() (when passed a large count so as to guarantee that all
neighbors are returned), but this method returns only a count of the individuals, not a vector
containing the individuals. This method may also be called in a vectorized fashion, with a non-
singleton vector of individuals, unlike nearestNeighbors().
Note that this method does not use interaction eligibility as a criterion; it will count neighbors that
cannot exert an interaction upon a receiver (due to sex-segregation, e.g.). (It still does not count a
receiver as a neighbor of itself, however.) If a count of only interacting neighbors is desired, use
interactingNeighborCount(). If the InteractionType is non-spatial, this method may not be
called.
– (integer$)neighborCountOfPoint(float point, io<Subpopulation>$ exerterSubpop)
Returns the number of individuals in exerterSubpop that are within the maximum interaction
distance according to the distance metric of the InteractionType. The subpopulation may be
supplied either as an integer ID, or as a Subpopulation object. The evaluate() method must
have been previously called for exerterSubpop, and positions saved at evaluation time will be used.
If the InteractionType is non-spatial, this method may not be called.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 663
This method is similar to nearestNeighborsOfPoint() (when passed a large count so as to
guarantee that all neighbors are returned), but this method returns only a count of the individuals, not
a vector containing the individuals.
– (void)setInteractionFunction(string$ functionType, ...)
Set the function used to translate spatial distances into interaction strengths for an interaction type.
The functionType may be "f", in which case the ellipsis ... should supply a numeric$ fixed
interaction strength; "l", in which case the ellipsis should supply a numeric$ maximum strength for a
linear function; "e", in which case the ellipsis should supply a numeric$ maximum strength and a
numeric$ lambda (shape) parameter for a negative exponential function; "n", in which case the
ellipsis should supply a numeric$ maximum strength and a numeric$ sigma (standard deviation)
parameter for a Gaussian function; or "c", in which case the ellipsis should supply a numeric$
maximum strength and a numeric$ scale parameter for a Cauchy distribution function. See section
24.8 above for discussions of these interaction functions. Non-spatial interactions must use function
type "f", since no distance values are available in that case.
The interaction function for an interaction type is normally a constant in simulations; in any case, it
cannot be changed when an interaction has already been evaluated, so either it should be set prior to
evaluation, or unevaluate() should be called first.
– (float)strength(object<Individual>$ receiver, [No<Individual> exerters = NULL])
Returns a vector containing the interaction strengths exerted upon receiver by the individuals in
exerters. If exerters is NULL (the default), then a vector of the interaction strengths exerted by all
individuals in the subpopulation of receiver (including receiver itself) is returned; this case may be
handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly
provided. Otherwise, all individuals in exerters must belong to a single subpopulation (but not
necessarily the same subpopulation as receiver). The evaluate() method must have been
previously called for the receiver and exerter subpopulations, and positions saved at evaluation time
will be used.
If the strengths of interactions exerted by a single individual upon multiple individuals are needed
instead (the inverse of what this method provides), multiple calls to this method will be necessary, one
per pairwise interaction queried; the interaction engine is not optimized for the inverse case, and so it
will likely be quite slow to compute. If the interaction is reciprocal and sex-symmetric, the opposite
query should provide identical results in a single efficient call (because then the interactions exerted
are equal to the interactions received); otherwise, the best approach might be to define a second
interaction type representing the inverse interaction that you wish to be able to query efficiently.
– (float)totalOfNeighborStrengths(object<Individual> receivers,
[No<Subpopulation>$ exerterSubpop = NULL])
Returns a vector of the total interaction strength felt by each individual in receivers by the exerters
in exerterSubpop (or, if that is NULL, then by all individuals in the receiver’s subpopulation). The
receivers parameter does not need to be a singleton; indeed, it can be a vector of all of the
individuals in a given subpopulation. All of the receivers must belong to a single subpopulation, and
all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to
be the same. The evaluate() method must have been previously called for the receiver and exerter
subpopulations, and positions saved at evaluation time will be used. If the InteractionType is non-
spatial, this method may not be called.
For one individual, this is essentially the same as calling nearestInteractingNeighbors() with a
large count so as to obtain the complete vector of all interacting neighbors, calling strength() for
each of those interactions to get each interaction strength, and adding those interaction strengths
together with sum(). This method is much faster than that implementation, however, since all of that
work is done as a single operation. Also, totalOfNeighborStrengths() can total up interactions
for more than one receiver in a single call.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 664
Similarly, for one individual this is essentially the same as calling strength() to get the interaction
strengths between a receiver and all individuals in the exerter subpopulation, and then calling sum().
Again, this method should be much faster, since this algorithm looks only at neighbors, whereas
calling strength() directly assesses interaction strengths with all other individuals. This will make a
particularly large difference when the subpopulation size is large and the maximum distance of the
InteractionType is small.
See localPopulationDensity() for a related method that calculates the total interaction strength
divided by the amount of “interaction field” present for an individual (i.e., the integral of the
interaction function clipped to the spatial bounds of the subpopulation) to provide an estimate of the
“interaction density” felt by an individual.
– (void)unevaluate(void)
Discards all evaluation of this interaction, for all subpopulations. The state of the InteractionType
is reset to a state prior to evaluation. This can be useful if the model state has changed in such a way
that the evaluation already conducted is no longer valid. For example, if the maximum distance or the
interaction function of the InteractionType need to be changed with immediate effect, or if the data
used by an interaction() callback has changed in such a way that previously calculated interaction
strengths are no longer correct, unevaluate() allows the interaction to begin again from scratch.
In WF models, all interactions are automatically reset to an unevaluated state at the moment when the
new offspring generation becomes the parental generation (at step 4 in the tick cycle; see section
22.4).
In nonWF models, all interactions are automatically reset to an unevaluated state twice per tick:
immediately after reproduction() callbacks have completed (after step 1 in the tick cycle; see
section 23.1), and immediately before viability/survival selection (before step 4 in the tick cycle; see
section 23.4).
Given this automatic invalidation, most simulations have no reason to call unevaluate().
