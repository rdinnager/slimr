– (void)addCustomColumn(string$ columnName, string$ source, [* context = NULL])
Adds a new data column with its name provided by columnName. The value for the column, when a
given row is generated, will be produced by the code supplied in source, which is expected to return
either NULL (which will write out NA), or a singleton value of any non-object type.
The context parameter will be set up as a pseudo-parameter, named context, when source is
called, allowing the same source code to be used to generate values for multiple data columns; you
might, for example, provide the particular Subpopulation object here that you wish source to use
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 666
for its calculations. This is optional; if the default value of NULL is used, then context will be NULL
when source is called.
See addMeanSDColumns() for a useful variant.
– (void)addCycle([No<Species>$ species = NULL])
Adds a new data column that provides the cycle counter for species (the same as the value of the
cycle property of that species). In single-species models, species may be NULL to indicate that
single species. The column will simply be named cycle in single-species models; an underscore and
the name of the species will be appended in multispecies models.
– (void)addCycleStage(void)
Adds a new data column that provides the cycle stage, named cycle_stage. The stage is provided as
a string, and will typically be "first", "early", "late", or "end" (the latter used for the point in
time at which end-of-tick automatic logging occurs). Other possible values are discussed in the
documentation for the cycleStage property of Community, which this column reflects.
– (void)addKeysAndValuesFrom(object$ source)
This Dictionary method has an override in LogFile to make it illegal to call, since LogFile
manages its Dictionary entries.
– (void)addMeanSDColumns(string$ columnName, string$ source, [* context = NULL])
Adds two new data columns with names of columnName_mean and columnName_sd. When a given
row is generated, the code supplied in source is expected to return either a zero-length vector of any
type including NULL (which will write out NA to both columns), or a non-zero-length vector of
integer or float values. In the latter case, the result vector will be summarized in the two columns
by its mean and standard deviation respectively. If the result vector has exactly one value, the
standard deviation will be written as NA. The context parameter is set up as a pseudo-parameter
when source is called, as described in addCustomColumn().
– (void)addPopulationSexRatio([No<Species>$ species = NULL])
Adds a new data column that provides the population sex ratio M:(M+F) for species. In single-
species models, species may be NULL to indicate that single species. The column will simply be
named sex_ratio in single-species models; an underscore and the name of the species will be
appended in multispecies models. If the species is hermaphroditic, NA will be written.
– (void)addPopulationSize([No<Species>$ species = NULL])
Adds a new data column that provides the total population size for species. In single-species
models, species may be NULL to indicate that single species. The column will simply be named
num_individuals in single-species models; an underscore and the name of the species will be
appended in multispecies models.
– (void)addSubpopulationSexRatio(io<Subpopulation>$ subpop)
Adds a new data column that provides the sex ratio M:(M+F) of the subpopulation subpop, named
pX_sex_ratio. If the subpopulation exists but has a size of zero, NA will be written.
– (void)addSubpopulationSize(io<Subpopulation>$ subpop)
Adds a new data column that provides the size of the subpopulation subpop, named
pX_num_individuals. If the subpopulation exists but has a size of zero, 0 will be written.
– (void)addSuppliedColumn(string$ columnName)
Adds a new data column with its name provided by columnName. The value for the column is initially
undefined, and will be written as NA. A different value may (optionally) be provided by calling
setSuppliedValue() with a value for columnName. That value will be used for the column the next
time a row is generated (whether automatically or by a call to logRow()), and the column’s value will
subsequently be undefined again. In other words, for any given logged row the default of NA may be
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 667
kept, or a different value may be supplied. This allows the value for the column to be set at any point
during the tick cycle, which can be convenient if the column’s value depends upon transient state that
is no longer available at the time the row is logged.
– (void)addTick(void)
Adds a new data column, named tick, that provides the tick number for the simulation.
– (void)clearKeysAndValues(void)
This Dictionary method has an override in LogFile to make it illegal to call, since LogFile
manages its Dictionary entries.
– (void)flush(void)
Flushes all buffered data to the output file, synchronously. This will make the contents of the file on
disk be up-to-date with the running simulation. Flushing frequently may entail a small performance
penalty. More importantly, if .gz compression has been requested with compress=T the size of the
resulting file will be larger – potentially much larger – if flush() is called frequently. Note that
automatic periodic flushing can be requested with the flushInterval parameter to
createLogFile().
– (void)logRow(void)
This logs a new row of data, by evaluating all of the generators added to the LogFile with add...()
calls. Note that the new row may be buffered, and thus may not be written out to disk immediately;
see flush(). This method may be used instead of, or in conjunction with, automatic logging.
You can get the LogFile instance, in order to call logRow() on it, from community.logFiles, or
you can remember it in a global constant with defineConstant().
– (void)setLogInterval([Ni$ logInterval = NULL])
Sets the automatic logging interval. A logInterval of NULL stops automatic logging immediately.
Other values request that a new row should be logged (as if logRow() were called) at the end of every
logInterval ticks (just before the tick count increment, in both WF and nonWF models), starting at
the end of the tick in which setLogInterval() was called.
– (void)setFilePath(string$ filePath, [Ns initialContents = NULL],
[logical$ append = F], [Nl$ compress = NULL], [Ns$ sep = NULL])
Redirects the LogFile to write new rows to a new filePath. Any rows that have been buffered but
not flushed will be written to the previous file first, as if flush() had been called. With this call, new
initialContents may be supplied, which will either replace any existing file or will be appended to
it, depending upon the value of append. New values may be supplied for compress and sep; the
meaning of these parameters is identical to their meaning in createLogFile(), except that a value of
NULL for these means “do not change this setting from its previous value”. In effect, then, this method
lets you start a completely new log file at a new path, without having to create and configure a new
LogFile object. The new file will be created (or appended) synchronously, with the specified initial
contents.
– (void)setSuppliedValue(string$ columnName, +$ value)
Registers a value, passed in value, to be used for the supplied column named columnName when a
row is next logged. This column must have been added with addSuppliedColumn(). A value of
NULL may be passed to log NA, but logging NA is the default behavior for supplied columns in any
case. Otherwise, the value must be a singleton, and its type should match the values previously
supplied for the column (otherwise the log file may be difficult to parse, since the values within the
column will not be of one consistent type). See addSuppliedColumn() for further details.
– (void)setValue(string$ key, * value)
This Dictionary method has an override in LogFile to make it illegal to call, since LogFile
manages its Dictionary entries.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 668
– (logical$)willAutolog(void)
Returns T if the log file is configured to log a new row automatically at the end of the current tick;
otherwise, returns F. This is useful for calculating a value that will be logged only in ticks when the
value is needed.
