(is)codonsToAminoAcids(integer codons, [li$ long = F], [logical$ paste = T])
Returns the amino acid sequence corresponding to the codon sequence in codons. Codons should be
represented with values in [0, 63] where AAA is 0, AAC is 1, AAG is 2, and TTT is 63; see
ancestralNucleotides() for discussion of this encoding. If long is F (the default), the standard
single-letter codes for amino acids will be used (where Serine is "S", etc.); if long is T, the standard
three-letter codes will be used instead (where Serine is "Ser", etc.). Beginning in SLiM 3.5, if long is
0, integer codes will be used as follows (and paste will be ignored):
stop (TAA, TAG, TGA) 0
Alanine 1
Arginine 2
Asparagine 3
Aspartic acid (Aspartate) 4
Cysteine 5
Glutamine 6
Glutamic acid (Glutamate) 7
Glycine 8
Histidine 9
Isoleucine 10
Leucine 11
Lysine 12
Methionine 13
Phenylalanine 14
Proline 15
Serine 16
Threonine 17
Tryptophan 18
Tyrosine 19
Valine 20
There does not seem to be a widely used standard for integer coding of amino acids, so SLiM just
numbers them alphabetically, making stop codons 0. If you want a different coding, you can make
your own 64-element vector and use it to convert codons to whatever integer codes you need. Other
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 703
integer values of long are reserved for future use (to support other codings), and will currently
produce an error.
When long is T or F and paste is T (the default), the amino acid sequence returned will be a
singleton string, such as "LYATI" (when long is F) or "Leu-Tyr-Ala-Thr-Ile" (when long is T).
When long is T or F and paste is F, the amino acid sequence will instead be returned as a string
vector, with one element per amino acid, such as "L" "Y" "A" "T" "I" (when long is F) or "Leu"
"Tyr" "Ala" "Thr" "Ile" (when long is T). Using the paste=T option is considerably faster than
using paste() in script.
This function interprets the supplied codon sequence as the sense strand (i.e., the strand that is not
transcribed, and which mirrors the mRNA’s sequence). This uses the standard DNA codon table
directly. For example, if the nucleotide sequence is CAA TTC, that will correspond to a codon vector
of 16 61, and will result in the amino acid sequence Gln-Phe (“QF").
(is)codonsToNucleotides(integer codons, [string$ format = "string"])
Returns the nucleotide sequence corresponding to the codon sequence supplied in codons. Codons
should be represented with values in [0, 63] where AAA is 0, AAC is 1, AAG is 2, and TTT is 63; see
ancestralNucleotides() for discussion of this encoding.
The format parameter controls the format of the returned sequence. It may be "string" to obtain
the sequence as a singleton string (e.g., "TATACG"), "char" to obtain it as a string vector of single
characters (e.g., "T", "A", "T", "A", "C", "G"), or "integer" to obtain it as an integer vector (e.g.,
3, 0, 3, 0, 1, 2), using SLiM’s standard code of A=0, C=1, G=2, T=3.
(float)mm16To256(float mutationMatrix16)
Returns a 64×4 mutation matrix that is functionally identical to the supplied 4×4 mutation matrix in
mutationMatrix16. The mutation rate for each of the 64 trinucleotides will depend only upon the
central nucleotide of the trinucleotide, and will be taken from the corresponding entry for the same
nucleotide in mutationMatrix16. This function can be used to easily construct a simple
trinucleotide-based mutation matrix which can then be modified so that specific trinucleotides sustain
a mutation rate that does not depend only upon their central nucleotide.
See the documentation for initializeGenomicElementType() in section 24.1 for further discussion
of how these 64×4 mutation matrices are interpreted and used.
(float)mmJukesCantor(float$ alpha)
Returns a mutation matrix representing a Jukes–Cantor (1969) model with mutation rate alpha to each
possible alternative nucleotide at a site:
This 2×2 matrix is suitable for use with initializeGenomicElementType(). Note that the actual
mutation rate produced by this matrix is 3*alpha.
(float)mmKimura(float$ alpha, float$ beta)
Returns a mutation matrix representing a Kimura (1980) model with transition rate alpha and
transversion rate beta:
This 2×2 matrix is suitable for use with initializeGenomicElementType(). Note that the actual
mutation rate produced by this model is alpha+2*beta.
0 α α α
α 0 α α
α α 0 α
α α α 0
0 β α β
β 0 β α
α β 0 β
β α β 0
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 704
(integer)nucleotideCounts(is sequence)
A convenience function that returns an integer vector of length four, providing the number of
occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence. The
parameter sequence may be a singleton string (e.g., "TATA"), a string vector of single characters
(e.g., "T", "A", "T", "A"), or an integer vector (e.g., 3, 0, 3, 0), using SLiM’s standard code of A=0,
C=1, G=2, T=3.
(float)nucleotideFrequencies(is sequence)
A convenience function that returns a float vector of length four, providing the frequencies of
occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence. The
parameter sequence may be a singleton string (e.g., "TATA"), a string vector of single characters
(e.g., "T", "A", "T", "A"), or an integer vector (e.g., 3, 0, 3, 0), using SLiM’s standard code of A=0,
C=1, G=2, T=3.
(integer)nucleotidesToCodons(is sequence)
Returns the codon sequence corresponding to the nucleotide sequence in sequence. The codon
sequence is an integer vector with values from 0 to 63, based upon successive nucleotide triplets in
the nucleotide sequence. The codon value for a given nucleotide triplet XYZ is 16X + 4Y + Z, where
X, Y, and Z have the usual values A=0, C=1, G=2, T=3. For example, the triplet AAA has a codon
value of 0, AAC is 1, AAG is 2, AAT is 3, ACA is 4, and on upward to TTT which is 63. If the
nucleotide sequence AACACATTT is passed in, the codon vector 1 4 63 will therefore be returned.
These codon values can be useful in themselves; they can also be passed to codonsToAminoAcids()
to translate them into the corresponding amino acid sequence if desired.
The nucleotide sequence in sequence may be supplied in any of three formats: a string vector with
single-letter nucleotides (e.g., "T", "A", "T", "A"), a singleton string of nucleotide letters (e.g.,
"TATA"), or an integer vector of nucleotide values (e.g., 3, 0, 3, 0) using SLiM’s standard code of
A=0, C=1, G=2, T=3. If the choice of format is not driven by other considerations, such as ease of
manipulation, then the singleton string format will certainly be the most memory-efficient for long
sequences, and will probably also be the fastest. The nucleotide sequence provided must be a
multiple of three in length, so that it translates to an integral number of codons.
(is)randomNucleotides(integer$ length, [Nif basis = NULL],
[string$ format = "string"])
Generates a new random nucleotide sequence with length bases. The four nucleotides ACGT are
equally probable if basis is NULL (the default); otherwise, basis may be a 4-element integer or
float vector providing relative fractions for A, C, G, and T respectively (these need not sum to 1.0, as
they will be normalized). More complex generative models such as Markov processes are not
supported intrinsically in SLiM at this time, but arbitrary generated sequences may always be loaded
from files on disk.
The format parameter controls the format of the returned sequence. It may be "string" to obtain
the generated sequence as a singleton string (e.g., "TATA"), "char" to obtain it as a string vector
of single characters (e.g., "T", "A", "T", "A"), or "integer" to obtain it as an integer vector (e.g., 3,
0, 3, 0), using SLiM’s standard code of A=0, C=1, G=2, T=3. For passing directly to
initializeAncestralNucleotides(), format "string" (a singleton string) will certainly be the
most memory-efficient, and probably also the fastest. Memory efficiency can be a significant
consideration; the nucleotide sequence for a chromosome of length 109 will occupy approximately 1
GB of memory when stored as a singleton string (with one byte per nucleotide), and much more if
stored in the other formats. However, the other formats can be easier to work with in Eidos, and so
may be preferable for relatively short chromosomes if you are manipulating the generated sequence.
(float$)calcFST(object<Genome> genomes1, object<Genome> genomes2,
[No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])
Calculates the FST between two Genome vectors – typically, but not necessarily, the genomes that
constitute two different subpopulations (which we will assume for the purposes of this discussion). In
general, higher FST indicates greater genetic divergence between subpopulations.
The calculation is done using only the mutations in muts; if muts is NULL, all mutations are used. The
muts parameter can therefore be used to calculate the FST only for a particular mutation type (by
passing only mutations of that type).
The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by
passing the interval bounds [start, end] for the desired window. In this case, the vector of mutations
used for the calculation will be subset to include only mutations within the specified window. The
default behavior, with start and end of NULL, provides the genome-wide FST, which is often used to
assess the overall level of genetic divergence between sister species or allopatric subpopulations.
The code for calcFST() is, roughly, an Eidos implementation of Wright’s definition of FST (but see
below for further discussion and clarification):
where HS is the average heterozygosity in the two subpopulations, and HT is the total heterozygosity
when both subpopulations are combined. In this implementation, the two genome vectors are
weighted equally, not weighted by their size. In SLiM 3, the implementation followed Wright’s
definition closely, and returned the average of ratios: mean(1.0 - H_s/H_t), in the Eidos code. In
SLiM 4, it returns the ratio of averages instead: 1.0 - mean(H_s)/mean(H_t). In other words, the FST
value reported by SLiM 4 is an average across the specified mutations in the two sets of genomes,
where H_s and H_t are first averaged across all specified mutations prior to taking the ratio of the two.
This ratio of averages is less biased than the average of ratios, and and is generally considered to be
best practice (see, e.g., Bhatia et al., 2013). This means that the behavior of calcFST() differs
between SLiM 3 and SLiM 4.
The implementation of calcFST(), viewable with functionSource(), treats every mutation in muts
as independent in the heterozygosity calculations; in other words, if mutations are stacked, the
heterozygosity calculated is by mutation, not by site. Similarly, if multiple Mutation objects exist in
different genomes at the same site (whether representing different genetic states, or multiple
mutational lineages for the same genetic state), each Mutation object is treated separately for
purposes of the heterozygosity calculation, just as if they were at different sites. One could regard
these choices as embodying an infinite-sites interpretation of the segregating mutations. In most
biologically realistic models, such genetic states will be quite rare, and so the impact of these choices
will be negligible; however, in some models these distinctions may be important.
FST = 1 − HS
HT
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 706
(float$)calcHeterozygosity(object<Genome> genomes, [No<Mutation> muts = NULL],
[Ni$ start = NULL], [Ni$ end = NULL])
Calculates the heterozygosity for a vector of genomes, based upon the frequencies of mutations in the
genomes. The result is the expected heterozygosity, for the individuals to which the genomes belong,
assuming that they are under Hardy-Weinberg equilibrium; this can be compared to the observed
heterozygosity of an individual, as calculated by calcPairHeterozygosity(). Often genomes will
be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be
used. By default, with muts=NULL, the calculation is based upon all mutations in the simulation; the
calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation
type, by passing the desired vector of mutations for muts.
The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by
passing the interval bounds [start, end] for the desired window. In this case, the vector of mutations
used for the calculation will be subset to include only mutations within the specified window. The
default behavior, with start and end of NULL, provides the genome-wide heterozygosity.
The implementation of calcHeterozygosity(), viewable with functionSource(), treats every
mutation as independent in the heterozygosity calculations. One could regard this choice as
embodying an infinite-sites interpretation of the segregating mutations. In most biologically realistic
models, such genetic states will be quite rare, and so the impact of this choice will be negligible;
however, in some models this distinction may be important. See calcPairHeterozygosity() for
further discussion.
(float$)calcInbreedingLoad(object<Genome> genomes,
[No<MutationType>$ mutType = NULL])
Calculates inbreeding load (the haploid number of lethal equivalents, or B) for a vector of genomes
passed in genomes. The calculation can be limited to a focal mutation type passed in mutType; if
mutType is NULL (the default), all of the mutations for the focal species will be considered. In any
case, only deleterious mutations (those with a negative selection coefficient) will be included in the
final calculation.
The inbreeding load is a measure of the quantity of recessive deleterious variation that is heterozygous
in a population and can contribute to fitness declines under inbreeding. This function implements the
following equation from Morton et al. (1956), which assumes no epistasis and random mating:
B = sum(qs) − sum(q2s) − 2sum(q(1−q)sh)
where q is the frequency of a given deleterious allele, s is the absolute value of the selection
coefficient, and h is its dominance coefficient. Note that the implementation sets a maximum |s| of
1.0 (i.e., a lethal allele); |s| can sometimes be greater than 1.0 when s is drawn from a distribution,
but in practice an allele with s < -1.0 has the same lethal effect as when s = -1.0. Also note that this
implementation will not work when the model changes the dominance coefficients of mutations using
mutationEffect() callbacks, since it relies on the dominanceCoeff property of MutationType.
Finally, note that, to estimate the diploid number of lethal equivalents (2B), the result from this
function can simply be multiplied by two.
This function was contributed by Chris Kyriazis; thanks, Chris!
(float$)calcPairHeterozygosity(object<Genome>$ genome1, object<Genome>$ genome2,
[Ni$ start = NULL], [Ni$ end = NULL], [logical$ infiniteSites = T])
Calculates the heterozygosity for a pair of genomes; these will typically be the two genomes of a
diploid individual (individual.genome1 and individual.genome2), but any two genomes may be
supplied.
The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by
passing the interval bounds [start, end] for the desired window. In this case, the vector of mutations
used for the calculation will be subset to include only mutations within the specified window. The
default behavior, with start and end of NULL, provides the genome-wide heterozygosity.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 707
The implementation calcPairHeterozygosity(), viewable with functionSource(), treats every
mutation as independent in the heterozygosity calculations by default (i.e., with infiniteSites=T).
If mutations are stacked, the heterozygosity calculated therefore depends upon the number of
unshared mutations, not the number of differing sites. Similarly, if multiple Mutation objects exist in
different genomes at the same site (whether representing different genetic states, or multiple
mutational lineages for the same genetic state), each Mutation object is treated separately for
purposes of the heterozygosity calculation, just as if they were at different sites. One could regard
these choices as embodying an infinite-sites interpretation of the segregating mutations. In most
biologically realistic models, such genetic states will be quite rare, and so the impact of this choice
will be negligible; however, in some models this distinction may be important. The behavior of
calcPairHeterozygosity() can be switched to calculate based upon the number of differing sites,
rather than the number of unshared mutations, by passing infiniteSites=F.
(float$)calcVA(object<Individual> individuals, io<MutationType>$ mutType)
Calculates VA, the additive genetic variance, among a vector individuals, in a particular mutation
type mutType that represents quantitative trait loci (QTLs) influencing a quantitative phenotypic trait.
The mutType parameter may be either an integer representing the ID of the desired mutation type,
or a MutationType object specified directly.
This function assumes that mutations of type mutType encode their effect size upon the quantitative
trait in their selectionCoeff property, as is fairly standard in SLiM (see, e.g., section 13.2). The
implementation of calcVA(), which is viewable with functionSource(), is quite simple; if effect
sizes are stored elsewhere (such as with setValue(), as in section 13.5), a new user-defined function
following the pattern of calcVA() can easily be written.
(float$)calcWattersonsTheta(object<Genome> genomes, [No<Mutation> muts = NULL],
[Ni$ start = NULL], [Ni$ end = NULL])
Calculates Watterson’s theta (a metric of genetic diversity comparable to heterozygosity) for a vector of
genomes, based upon the mutations in the genomes. Often genomes will be all of the genomes in a
subpopulation, or in the entire population, but any genome vector may be used. By default, with
muts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead
be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the
desired vector of mutations for muts.
The calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by
passing the interval bounds [start, end] for the desired window. In this case, the vector of mutations
used for the calculation will be subset to include only mutations within the specified window. The
default behavior, with start and end of NULL, provides the genome-wide Watterson’s theta.
The implementation of calcWattersonsTheta(), viewable with functionSource(), treats every
mutation as independent in the heterozygosity calculations. One could regard this choice as
embodying an infinite-sites interpretation of the segregating mutations, as with
calcHeterozygosity(). In most biologically realistic models, such genetic states will be quite rare,
and so the impact of this assumption will be negligible; however, in some models this distinction may
be important. See calcPairHeterozygosity() for further discussion.
(float)summarizeIndividuals(object<Individual> individuals, integer dim,
numeric spatialBounds, string$ operation, [Nlif$ empty = 0.0],
[logical$ perUnitArea = F], [Ns$ spatiality = NULL])
Returns a vector, matrix, or array that summarizes spatial patterns of information related to the
individuals in individuals. In essence, those individuals are assigned into bins according to their
spatial position, and then a summary value for each bin is calculated based upon the individuals each
bin contains. The individuals might be binned in one dimension (resulting in a vector of summary
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 708
values), in two dimensions (resulting in a matrix), or in three dimensions (resulting in an array).
Typically the spatiality of the result (the dimensions into which the individuals are binned) will match
the dimensionality of the model, as indicated by the default value of NULL for the optional
spatiality parameter; for example, a two-dimensional ("xy") model would by default produce a
two-dimensional matrix as a summary. However, a spatiality that is more restrictive than the model
dimensionality may be passed; for example, in a two-dimensional ("xy") model a spatiality of "y"
could be passed to summarize individuals into a vector, rather than a matrix, assigning them to bins
based only upon their y position (i.e., the value of their y property). Whatever spatiality is chosen, the
parameter dim provides the dimensions of the desired result, in the same form that the dim() function
does: first the number of rows, then the number of columns, and then the number of planes, as
needed (see the Eidos manual for discussion of matrices, arrays, and dim()). The length of dims must
match the requested spatiality; for spatiality "xy", for example, dims might be c(50,100) to request
that the returned matrix have 50 rows and 100 columns. The result vector/matrix/array is in the correct
orientation to be directly usable as a spatial map, by passing it to the defineSpatialMap() method
of Subpopulation. For further discussion of dimensionality and spatiality, see section 24.1 on
initializeInteractionType(), and section 24.8 on InteractionType.
The spatialBounds parameter defines the spatial boundaries within which the individuals are
binned. Typically this is the spatial bounds of a particular subpopulation, within which the individuals
reside; for individuals in p1, for example, you would likely pass p1.spatialBounds for this.
However, this is not required; individuals may come from any or all subpopulations in the model, and
spatialBounds may be any bounds of non-zero area (if an individual falls outside of the given spatial
bounds, it is excluded, as if it were not in individuals at all). If you have multiple subpopulations
that conceptually reside within the same overall coordinate space, for example, that can be
accommodated here. The bounds are supplied in the dimensionality of the model, in the same form
as for Subpopulation; for an "xy" model, for example, they are supplied as a four-element vector of
the form c(x0, y0, x1, y1) even if the summary is being produced with spatiality "y". To produce
the result, a grid with dimensions defined by dims is conceptually stretched out across the given
spatial bounds, such that the centers of the edge and corner grid squares are aligned with the limits of
the spatial bounds. This matches the way that defineSpatialMap() defines its maps; see section
15.11 for illustration.
The particular summary produced depends upon the parameters operation and empty. Consider a
single grid square represented by a single element in the result. That grid square contains zero or
more of the individuals in individuals. If it contains zero individuals and empty is not NULL, the
empty value is used for the result, regardless of operation, providing specific, separate control over
the treatment of empty grid squares. If empty is NULL, this separate control over the treatment of
empty grid squares is declined; empty grid squares will be handled through the standard mechanism
described next. In all other cases for the given grid square – when it contains more than zero
individuals, or when empty is NULL – operation is executed as an Eidos lambda, a small snippet of
code, supplied as a singleton string, that is executed in a manner similar to a function call. Within
the execution of the operation lambda, a constant named individuals is defined to be the focal
individuals being evaluated – all of the individuals within that grid square. This lambda should
evaluate to a singleton logical, integer, or float value, comprising the result value for the grid
square; these types will all be coerced to float (T being 1 and F being 0).
Two examples may illustrate the use of empty and operation. To produce a summary indicating
presence/absence, simply use the default of 0.0 for empty, and "1.0; " (or "1;", or "T;") for
operation. This will produce 0.0 for empty grid squares, and 1.0 for those that contain at least one
individual. Note that the use of empty is essential here, because operation doesn’t even check
whether individuals are present or not. To produce a summary with a count of the number of
individuals in each grid square, again use the default of 0.0 for empty, but now use an operation of
"individuals.size();", counting the number of individuals in each grid square. In this case,
empty could be NULL instead and operation would still produce the correct result; but using empty
makes summarizeIndividuals() more efficient since it allows the execution of operation to be
skipped for those squares.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 709
Lambdas are not limited in their complexity; they can use if, for, etc., and can call methods and
functions. A typical operation to compute the mean phenotype in a quantitative genetic model that
stores phenotype values in tagF, for example, would be "mean(individuals.tagF);", and this is
still quite simple compared to what is possible. However, keep in mind that the lambda will be
evaluated for every grid cell (or at least those that are non-empty), so efficiency can be a concern, and
you may wish to pre-calculate values shared by all of the lambda calls, making them available to your
lambda code using defineGlobal() or defineConstant().
There is one last twist, if perUnitArea is T: values are divided by the area (or length, in 1D, or
volume, in 3D) that their corresponding grid cell comprises, so that each value is in units of “per unit
area” (or “per unit length”, or “per unit volume”). The total area of the grid is defined by the spatial
bounds, and the area of a given grid cell is defined by the portion of the spatial bounds that is within
that cell. This is not the same for all grid cells; grid cells that fall partially outside spatialBounds
(because, remember, the centers of the edge/corner grid cells are aligned with the limits of
spatialBounds) will have a smaller area inside the bounds. For an "xy" spatiality summary, for
example, corner cells have only a quarter of their area inside spatialBounds, while edge elements
have half of their area inside spatialBounds; for purposes of perUnitArea, then, their respective
areas are ¼ and ½ the area of an interior grid cell. By default, perUnitArea is F, and no scaling is
performed. Whether you want perUnitArea to be F or T depends upon whether the summary you
are producing is, conceptually, “per unit area”, such as density (individuals per unit area) or local
competition strength (total interaction strength per unit area), or is not, such as “mean individual age”,
or “maximum tag value”. For the previous example of counting individuals with an operation of
"individuals.size();", a value of F for perUnitArea (the default) will produce a simple count of
individuals in each grid square, whereas with T it would produce the density of individuals in each
grid square.
(object<Dictionary>$)treeSeqMetadata(string$ filePath, [logical$ userData = T])
Returns a Dictionary containing top-level metadata from the .trees (tree-sequence) file at
filePath. If userData is T (the default), the top-level metadata under the SLiM/user_metadata key
is returned; this is the same metadata that can optionally be supplied to treeSeqOutput() in its
metadata parameter, so it makes it easy to recover metadata that you attached to the tree sequence
when it was saved. If userData is F, the entire top-level metadata Dictionary object is returned; this
can be useful for examining the values of other keys under the SLiM key (see section 26.4), or values
inside the top-level dictionary itself that might have been placed there by msprime or other software.
This function can be used to read in parameter values or other saved state (tag property values, for
example), in order to resuscitate the complete state of a simulation that was written to a .trees file.
It could be used for more esoteric purposes too, such as to search through .trees files in a directory
(with the help of the Eidos function filesAtPath()) to find those files that satisfy some metadata
criterion.
