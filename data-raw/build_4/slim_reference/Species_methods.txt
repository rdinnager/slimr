– (object<Subpopulation>$)addSubpop(is$ subpopID, integer$ size,
[float$ sexRatio = 0.5], [logical$ haploid = F])
Add a new subpopulation with id subpopID and size individuals. The subpopID parameter may be
either an integer giving the ID of the new subpopulation, or a string giving the name of the new
subpopulation (such as "p5" to specify an ID of 5). Only if sex is enabled for the species, the initial
sex ratio may optionally be specified as sexRatio (as the male fraction, M:M+F); if it is not specified,
a default of 0.5 is used. The new subpopulation will be defined as a global variable immediately by
this method (see section 25.16), and will also be returned by this method. Subpopulations added by
this method will initially consist of individuals with empty genomes. In order to model
subpopulations that split from an already existing subpopulation, use addSubpopSplit().
Only in nonWF models, the haploid parameter may be T; in this case, the second genome of each
new individual will be a null genome, rather than an empty genome. For even greater control in
nonWF models, you can call addSubpop() with an initial size of 0 and then stock the population with
new individuals created however you wish in the next tick’s reproduction() callback.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 719
– (object<Subpopulation>$)addSubpopSplit(is$ subpopID, integer$ size,
io<Subpopulation>$ sourceSubpop, [float$ sexRatio = 0.5])
Split off a new subpopulation with id subpopID and size individuals derived from subpopulation
sourceSubpop. The subpopID parameter may be either an integer giving the ID of the new
subpopulation, or a string giving the name of the new subpopulation (such as "p5" to specify an ID
of 5). The sourceSubpop parameter may specify the source subpopulation either as a
Subpopulation object or by integer identifier. Only if sex is enabled for the species, the initial sex
ratio may optionally be specified as sexRatio (as the male fraction, M:M+F); if it is not specified, a
default of 0.5 is used. The new subpopulation will be defined as a global variable immediately by
this method (see section 25.16), and will also be returned by this method.
Subpopulations added by this method will consist of individuals that are clonal copies of individuals
from the source subpopulation, randomly chosen with probabilities proportional to fitness. The fitness
of all of these initial individuals is considered to be 1.0, to avoid a doubled round of selection in the
initial tick, given that fitness values were already used to choose the individuals to clone. Once this
initial set of individuals has mated to produce offspring, the model is effectively of parental individuals
in the source subpopulation mating randomly according to fitness, as usual in SLiM, with juveniles
migrating to the newly added subpopulation. Effectively, then, then new subpopulation is created
empty, and is filled by migrating juveniles from the source subpopulation, in accordance with SLiM’s
usual model of juvenile migration.
– (integer$)countOfMutationsOfType(io<MutationType>$ mutType)
Returns the number of mutations that are of the type specified by mutType, out of all of the mutations
that are currently active in the species. If you need a vector of the matching Mutation objects, rather
than just a count, use -mutationsOfType(). This method is often used to determine whether an
introduced mutation is still active (as opposed to being either lost or fixed). This method is provided
for speed; it is much faster than the corresponding Eidos code.
– (object<Individual>)individualsWithPedigreeIDs(integer pedigreeIDs,
[Nio<Subpopulation> subpops = NULL])
Looks up individuals by pedigree ID, optionally within specific subpopulations. Pedigree tracking
must be turned on with initializeSLiMOptions(keepPedigrees=T) to use this method, otherwise
an error will result. This method is vectorized; more than one pedigree id may be passed in
pedigreeID, in which case the returned vector will contain all of the individuals for which a match
was found (in the same order in which they were supplied). If a given id is not found, the returned
vector will contain no entry for that id (so the length of the returned vector may not match the length
of pedigreeIDs). If none of the given ids were found, the returned vector will be
object<Individual>(0), an empty object vector of class Individual. If you have more than one
pedigree ID to look up, calling this method just once, in vectorized fashion, may be much faster than
calling it once for each ID, due to internal optimizations.
To find individuals within all subpopulations, pass the default of NULL for subpops. If you are
interested only in matches within a specific subpopulation, pass that subpopulation for subpops; that
will make the search faster. Similarly, if you know that a particular subpopulation is the most likely to
contain matches, you should supply that subpopulation first in the subpops vector so that it will be
searched first; the supplied subpopulations are searched in order. Subpopulations may be supplied
either as integer IDs, or as Subpopulation objects.
– (void)killIndividuals(object<Individual> individuals)
Immediately kills the individuals in individuals. This removes them from their subpopulation and
gives them an index value of -1. The Individual objects are not freed immediately, since references
to them could still exist in local Eidos variables; instead, the individuals are kept in a temporary
“graveyard” until they can be freed safely. It therefore continues to be safe to use them and their
genomes, except that accessing their subpopulation property will raise an error since they no longer
have a subpopulation.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 720
Note that the indices and order of individuals and genomes in all source subpopulations will change
unpredictably as a side effect of this method. All evaluated interactions are invalidated as a side effect
of calling this method.
Note that this method is only for use in nonWF models, in which mortality is managed manually by
the model script. In WF models, mortality is managed automatically by the SLiM core when the new
offspring generation becomes the parental generation and the previous parental generation dies;
mortality does not otherwise occur in WF models. In nonWF models, mortality normally occurs
during the survival stage of the tick cycle (see section 24.4), based upon the fitness values calculated
by SLiM, and survival() callbacks can influence the outcome of that survival stage. Calls to
killIndividuals(), on the other hand, can be made at any time during first(), early(), or
late() events, and the result cannot be modified by survival() callbacks; the given individuals are
simply immediately killed. This method therefore provides an alternative, and relatively rarely used,
mortality mechanism that is disconnected from fitness.
– (integer)mutationCounts(Nio<Subpopulation> subpops,
[No<Mutation> mutations = NULL])
Return an integer vector with the frequency counts of all of the Mutation objects passed in
mutations, within the Subpopulation objects in subpops. The subpops argument is required, but
you may pass NULL to get population-wide frequency counts. Subpopulations may be supplied either
as integer IDs, or as Subpopulation objects. If the optional mutations argument is NULL (the
default), frequency counts will be returned for all of the active Mutation objects in the species – the
same Mutation objects, and in the same order, as would be returned by the mutations property of
sim, in other words.
See the -mutationFrequencies() method to obtain float frequencies instead of integer counts.
See also the Genome methods mutationCountsInGenomes() and
mutationFrequenciesInGenomes().
– (float)mutationFrequencies(Nio<Subpopulation> subpops,
[No<Mutation> mutations = NULL])
Return a float vector with the frequencies of all of the Mutation objects passed in mutations,
within the Subpopulation objects in subpops. The subpops argument is required, but you may pass
NULL to get population-wide frequencies. Subpopulations may be supplied either as integer IDs, or
as Subpopulation objects. If the optional mutations argument is NULL (the default), frequencies will
be returned for all of the active Mutation objects in the species – the same Mutation objects, and in
the same order, as would be returned by the mutations property of sim, in other words.
See the -mutationCounts() method to obtain integer counts instead of float frequencies. See
also the Genome methods mutationCountsInGenomes() and mutationFrequenciesInGenomes().
– (object<Mutation>)mutationsOfType(io<MutationType>$ mutType)
Returns an object vector of all the mutations that are of the type specified by mutType, out of all of
the mutations that are currently active in the species. If you just need a count of the matching
Mutation objects, rather than a vector of the matches, use -countOfMutationsOfType(). This
method is often used to look up an introduced mutation at a later point in the simulation, since there
is no way to keep persistent references to objects in SLiM. This method is provided for speed; it is
much faster than the corresponding Eidos code.
– (void)outputFixedMutations([Ns$ filePath = NULL], [logical$ append = F])
Output all fixed mutations – all Substitution objects, in other words (see section 1.5.2) – in a SLiM
native format (see section 27.1.2 for output format details). If the optional parameter filePath is
NULL (the default), output will be sent to Eidos’s output stream (see section 4.2.1). Otherwise, output
will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or
appending to the end of it if append is T. Mutations which have fixed but have not been turned into
Substitution objects – typically because convertToSubstitution has been set to F for their
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 721
mutation type (see section 25.11.1) – are not output; they are still considered to be segregating
mutations by SLiM.
In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based
mutations; see section 27.1.2.
Output is generally done in a late() event, so that the output reflects the state of the simulation at
the end of a tick.
– (void)outputFull([Ns$ filePath = NULL], [logical$ binary = F],
[logical$ append = F], [logical$ spatialPositions = T], [logical$ ages = T],
[logical$ ancestralNucleotides = T], [logical$ pedigreeIDs = F])
Output the state of the entire population (see section 27.1.1 for output format details). If the optional
parameter filePath is NULL (the default), output will be sent to Eidos’s output stream (see section
4.2.1). Otherwise, output will be sent to the filesystem path specified by filePath, overwriting that
file if append if F, or appending to the end of it if append is T. When writing to a file, a logical flag,
binary, may be supplied as well. If binary is T, the population state will be written as a binary file
instead of a text file (binary data cannot be written to the standard output stream). The binary file is
usually smaller, and in any case will be read much faster than the corresponding text file would be
read. Binary files are not guaranteed to be portable between platforms; in other words, a binary file
written on one machine may not be readable on a different machine (but in practice it usually will be,
unless the platforms being used are fairly unusual). If binary is F (the default), a text file will be
written.
Beginning with SLiM 2.3, the spatialPositions parameter may be used to control the output of the
spatial positions of individuals in species for which continuous space has been enabled using the
dimensionality option of initializeSLiMOptions(). If spatialPositions is F, the output will
not contain spatial positions, and will be identical to the output generated by SLiM 2.1 and later. If
spatialPositions is T, spatial position information will be output if it is available (see section
27.1.1 for format details). If the species does not have continuous space enabled, the
spatialPositions parameter will be ignored. Positional information may be output for all output
destinations – the Eidos output stream, a text file, or a binary file.
Beginning with SLiM 3.0, the ages parameter may be used to control the output of the ages of
individuals in nonWF simulations. If ages is F, the output will not contain ages, preserving backward
compatibility with the output format of SLiM 2.1 and later. If ages is T, ages will be output for nonWF
models (see section 27.1.1 for format details). In WF simulations, the ages parameter will be ignored.
Beginning with SLiM 3.3, the ancestralNucleotides parameter may be used to control the output
of the ancestral nucleotide sequence in nucleotide-based models (see section 27.1.1 for format
details). If ancestralNucleotides is F, the output will not contain ancestral nucleotide information,
and so the ancestral sequence will not be restored correctly if the saved file is loaded with
readPopulationFile(). This option is provided because the ancestral sequence may be quite large,
for models with a long chromosome (e.g., 1 GB if the chromosome is 109 bases long, when saved in
text format, or 0.25 GB when saved in binary format). If the model is not nucleotide-based (as
enabled with the nucleotideBased parameter to initializeSLiMOptions()), the
ancestralNucleotides parameter will be ignored. Note that in nucleotide-based models the output
format will always include the nucleotides associated with any nucleotide-based mutations; the
ancestralNucleotides flag governs only the ancestral sequence.
Beginning with SLiM 3.5, the pedigreeIDs parameter may be used to request that pedigree IDs be
written out (and read in by readFromPopulationFile(), subsequently). This option is turned off (F)
by default, to preserve backward compatibility; if it is turned on (T), different file version values will be
used, and backward compatibility with previous versions of SLiM will be lost (see section 27.1.1).
This option may only be used if SLiM’s optional pedigree tracking has been enabled with
initializeSLiMOptions(keepPedigrees=T).
Output is generally done in a late() event, so that the output reflects the state of the simulation at
the end of a tick.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 722
– (void)outputMutations(object<Mutation> mutations, [Ns$ filePath = NULL],
[logical$ append = F])
Output all of the given mutations (see section 27.1.3 for output format details). This can be used to
output all mutations of a given mutation type, for example. If the optional parameter filePath is
NULL (the default), output will be sent to Eidos’s output stream (see section 4.2.1). Otherwise, output
will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or
appending to the end of it if append is T.
In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based
mutations; see section 27.1.3.
Output is generally done in a late() event, so that the output reflects the state of the simulation at
the end of a tick.
– (integer$)readFromPopulationFile(string$ filePath, [No$ subpopMap = NULL])
Read from a population initialization file, whether in text or binary format as previously specified to
outputFull(), and return the tick counter value represented by the file’s contents (i.e., the tick at
which the file was generated). Although this is most commonly used to set up initial populations
(often in an Eidos event set to run in tick 1, immediately after simulation initialization), it may be
called in any early() or late() Eidos event; the current state of all populations in the target species
will be wiped and replaced by the state in the file at filePath. All Eidos variables that are of type
object and have element type Subpopulation, Genome, Mutation, Individual, or Substitution
will be removed as a side effect of this method if they contain any element that belongs to the target
species, because those objects will no longer exist in the SLiM simulation; if you want to preserve any
of that state, you should output it or save it to a file prior to this call. New symbols will be defined to
refer to the new Subpopulation objects loaded from the file.
If the file being read was written by a version of SLiM prior to 2.3, then for backward compatibility
fitness values will be calculated immediately for any new subpopulations created by this call, which
will trigger the calling of any activated and applicable mutationEffect() and fitnessEffect()
callbacks. When reading files written by SLiM 2.3 or later, fitness values are not calculated as a side
effect of this call (because the simulation will often need to evaluate interactions or modify other state
prior to doing so).
In SLiM 2.3 and later when using the WF model, calling readFromPopulationFile() from any
context other than a late() event causes a warning; calling from a late() event is almost always
correct in WF models, so that fitness values can be automatically recalculated by SLiM at the usual
time in the tick cycle without the need to force their recalculation (see chapter 23, and comments on
recalculateFitness() below).
In SLiM 3.0 when using the nonWF model, calling readFromPopulationFile() from any context
other than an early() event causes a warning; calling from an early() event is almost always
correct in nonWF models, so that fitness values can be automatically recalculated by SLiM at the
usual time in the tick cycle without the need to force their recalculation (see chapter 24, and
comments on recalculateFitness() below).
As of SLiM 2.1, this method changes the tick and cycle counters to the tick and cycle read from the
file. If you do not want these counters to be changed, you can change them back after reading, by
setting community.tick and sim.cycle to whatever values you wish. Note that restoring a saved
past state and running forward again will not yield the same simulation results, because the random
number generator’s state will not be the same; to ensure reproducibility from a given time point,
setSeed() can be used to establish a new seed value. Any changes made to structure of the species
(mutation types, genomic element types, etc.) will not be wiped and re-established by
readFromPopulationFile(); this method loads only the population’s state, not the species
configuration, so care should be taken to ensure that the species structure meshes coherently with the
loaded data. Indeed, state such as the selfing and cloning rates of subpopulations, values set into tag
properties, and values set onto objects with setValue() will also be lost, since it is not saved out by
outputFull(). Only information saved by outputFull() will be restored; all other state associated
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 723
with the species – subpopulations, individuals, genomes, mutations, and substitutions – will be lost,
and should be re-established by the model if it is still needed.
As of SLiM 2.3, this method will read and restore the spatial positions of individuals if that information
is present in the output file and the species has enabled continuous space (see outputFull() for
details). If spatial positions are present in the output file but the species has not enabled continuous
space (or the number of spatial dimensions does not match), an error will result. If the species has
enabled continuous space but spatial positions are not present in the output file, the spatial positions
of the individuals read will be undefined, but an error is not raised.
As of SLiM 3.0, this method will read and restore the ages of individuals if that information is present
in the output file and the simulation is based upon the nonWF model. If ages are present but the
simulation uses a WF model, an error will result; the WF model does not use age information. If ages
are not present but the simulation uses a nonWF model, an error will also result; the nonWF model
requires age information.
As of SLiM 3.3, this method will restore the nucleotides of nucleotide-based mutations, and will
restore the ancestral nucleotide sequence, if that information is present in the output file. Loading an
output file that contains nucleotide information in a non-nucleotide-based model, and vice versa, will
produce an error.
As of SLiM 3.5, this method will read and restore the pedigree IDs of individuals and genomes if that
information is present in the output file (as requested with outputFull(pedigreeIDs=T)) and if
SLiM’s optional pedigree tracking has been enabled with
initializeSLiMOptions(keepPedigrees=T).
This method can also be used to read tree-sequence (.trees) files saved by treeSeqOutput() or
generated by the Python pyslim package. Note that the user metadata for a tree-sequence file can be
read separately with the treeSeqMetadata() function. Beginning with SLiM 4, the subpopMap
parameter may be supplied to re-order the populations of the input tree sequence when it is loaded in
to SLiM. This parameter must have a value that is a Dictionary; the keys of this dictionary should be
SLiM population identifiers as string values (e.g., "p2"), and the values should be indexes of
populations in the input tree sequence; a key/value pair of "p2", 4 would mean that the fifth
population in the input (the one at zero-based index 4) should become p2 on loading into SLiM. If
subpopMap is non-NULL, all populations in the tree sequence must be explicitly mapped, even if their
index will not change and even if they will not be used by SLiM; the only exception is for unused slots
in the population table, which can be explicitly remapped but do not have to be. For instance,
suppose we have a tree sequence in which population 0 is unused, population 1 is not a SLiM
population (for example, an ancestral population produced by msprime), and population 2 is a SLiM
population, and we want to load this in with population 2 as p0 in SLiM. To do this, we could supply
a value of Dictionary("p0", 2, "p1", 1, "p2", 0) for subpopMap, or we could leave out slot 0
since it is unused, with Dictionary("p0", 2, "p1", 1). Although this facility cannot be used to
remove populations in the tree sequence, note that it may add populations that will be visible when
treeSeqOutput() is called (although these will not be SLiM populations); if, in this example, we had
used Dictionary("p0", 0, "p1", 1, "p5", 2) and then we wrote the result out with
treeSeqOutput(), the resulting tree sequence would have six populations, although three of them
would be empty and would not be used by SLiM. The use of subpopMap makes it easier to load
simulation data that was generated in Python, since that typically uses an id of 0. The subpopMap
parameter may not be used with file formats other than tree-sequence files, at the present time; setting
up the correct subpopulation ids is typically easier when working with those other formats. Note the
tskit command-line interface can be used, like python3 -m tskit populations file.trees, to
find out the number of subpopulations in a tree-sequence file and their IDs.
When loading a tree sequence, a crosscheck of the loaded data will be performed to ensure that the
tree sequence was well-formed and was loaded correctly. When running a Release build of SLiM,
however, this crosscheck will only occur the first time that readFromPopulationFile() is called to
load a tree sequence; subsequent calls will not perform this crosscheck, for greater speed when
running models that load saved population state many times (such as models that are conditional on
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 724
fixation). If you suspect that a tree sequence file might be corrupted or read incorrectly, running a
Debug build of SLiM enables crosschecks after every load.
– (void)recalculateFitness([Ni$ tick = NULL])
Force an immediate recalculation of fitness values for all individuals in all subpopulations. Normally
fitness values are calculated at a fixed point in each tick, and those values are cached and used until
the next recalculation. If simulation parameters are changed in script in a way that affects fitness
calculations, and if you wish those changes to take effect immediately rather than taking effect at the
next automatic recalculation, you may call recalculateFitness() to force an immediate
recalculation and recache.
The optional parameter tick provides the tick for which mutationEffect() and fitnessEffect()
callbacks should be selected; if it is NULL (the default), the current tick value for the simulation,
community.tick, is used. If you call recalculateFitness() in an early() event in a WF model,
you may wish this to be community.tick - 1 in order to utilize the mutationEffect() and
fitnessEffect() callbacks for the previous tick, as if the changes that you have made to fitnessinfluencing
parameters were already in effect at the end of the previous tick when the new generation
was first created and evaluated (usually it is simpler to just make such changes in a late() event
instead, however, in which case calling recalculateFitness() is probably not necessary at all since
fitness values will be recalculated immediately afterwards). Regardless of the value supplied for tick
here, community.tick inside callbacks will report the true tick number, so if your callbacks consult
that parameter in order to create tick-specific fitness effects you will need to handle the discrepancy
somehow. (Similar considerations apply for nonWF models that call recalculateFitness() in a
late() event, which is also not advisable in general.)
After this call, the fitness values used for all purposes in SLiM will be the newly calculated values.
Calling this method will trigger the calling of any enabled and applicable mutationEffect() and
fitnessEffect() callbacks, so this is quite a heavyweight operation; you should think carefully
about what side effects might result (which is why fitness recalculation does not just occur
automatically after changes that might affect fitness values).
– (object<SLiMEidosBlock>$)registerFitnessEffectCallback(Nis$ id, string$ source,
[Nio<Subpopulation>$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
fitnessEffect() callback in the current simulation (specific to the target species), with an optional
subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all
subpopulations), and optional start and end ticks all limiting its applicability. The script block will
be given identifier id (specified as an integer, or as a string symbolic name such as "s5"); this
may be NULL if there is no need to be able to refer to the block later. The registered callback is added
to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be
eligible to execute in the current tick (see section 26.11 for details). The new SLiMEidosBlock will
be defined as a global variable immediately by this method (see section 25.12), and will also be
returned by this method.
– (object<SLiMEidosBlock>$)registerMateChoiceCallback(Nis$ id, string$ source,
[Nio<Subpopulation>$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
mateChoice() callback in the current simulation (specific to the target species), with optional
subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all
subpopulations) and optional start and end ticks all limiting its applicability. The script block will be
given identifier id (specified as an integer, or as a string symbolic name such as "s5"); this may
be NULL if there is no need to be able to refer to the block later. The registered callback is added to
the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible
to execute in the current tick (see section 26.11 for details). The new SLiMEidosBlock will be
defined as a global variable immediately by this method (see section 25.12), and will also be returned
by this method.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 725
– (object<SLiMEidosBlock>$)registerModifyChildCallback(Nis$ id, string$ source,
[Nio<Subpopulation>$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
modifyChild() callback in the current simulation (specific to the target species), with optional
subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all
subpopulations) and optional start and end ticks all limiting its applicability. The script block will be
given identifier id (specified as an integer, or as a string symbolic name such as "s5"); this may
be NULL if there is no need to be able to refer to the block later. The registered callback is added to
the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible
to execute in the current tick (see section 26.11 for details). The new SLiMEidosBlock will be
defined as a global variable immediately by this method (see section 25.12), and will also be returned
by this method.
– (object<SLiMEidosBlock>$)registerMutationCallback(Nis$ id, string$ source,
[Nio<MutationType>$ mutType = NULL], [Nio<Subpopulation>$ subpop = NULL],
[Ni$ start = NULL], [Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
mutation() callback in the current simulation (specific to the target species), with an optional
mutation type mutType (which may be an integer mutation type identifier, or NULL, the default, to
indicate all mutation types – see section 26.9), optional subpopulation subpop (which may also be an
integer identifier, or NULL, the default, to indicate all subpopulations), and optional start and end
ticks all limiting its applicability. The script block will be given identifier id (specified as an integer,
or as a string symbolic name such as "s5"); this may be NULL if there is no need to be able to refer
to the block later. The registered callback is added to the end of the list of registered SLiMEidosBlock
objects, and is active immediately; it may be eligible to execute in the current tick (see section 26.11
for details). The new SLiMEidosBlock will be defined as a global variable immediately by this
method (see section 25.12), and will also be returned by this method.
– (object<SLiMEidosBlock>$)registerMutationEffectCallback(Nis$ id, string$ source,
io<MutationType>$ mutType, [Nio<Subpopulation>$ subpop = NULL],
[Ni$ start = NULL], [Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
mutationEffect() callback in the current simulation (specific to the target species), with a required
mutation type mutType (which may be an integer mutation type identifier), optional subpopulation
subpop (which may also be an integer identifier, or NULL, the default, to indicate all
subpopulations), and optional start and end ticks all limiting its applicability. The script block will
be given identifier id (specified as an integer, or as a string symbolic name such as "s5"); this
may be NULL if there is no need to be able to refer to the block later. The registered callback is added
to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be
eligible to execute in the current tick (see section 26.11 for details). The new SLiMEidosBlock will
be defined as a global variable immediately by this method (see section 25.12), and will also be
returned by this method.
– (object<SLiMEidosBlock>$)registerRecombinationCallback(Nis$ id, string$ source,
[Nio<Subpopulation>$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
recombination() callback in the current simulation (specific to the target species), with optional
subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all
subpopulations) and optional start and end ticks all limiting its applicability. The script block will be
given identifier id (specified as an integer, or as a string symbolic name such as "s5"); this may
be NULL if there is no need to be able to refer to the block later. The registered callback is added to
the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible
to execute in the current tick (see section 26.11 for details). The new SLiMEidosBlock will be
defined as a global variable immediately by this method (see section 25.12), and will also be returned
by this method.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 726
– (object<SLiMEidosBlock>$)registerReproductionCallback(Nis$ id, string$ source,
[Nio<Subpopulation>$ subpop = NULL], [Ns$ sex = NULL], [Ni$ start = NULL],
[Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
reproduction() callback in the current simulation (specific to the target species), with optional
subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all
subpopulations), optional sex-specificity sex (which may be "M" or "F" in sexual species to make the
callback specific to males or females respectively, or NULL for no sex-specificity), and optional start
and end ticks all limiting its applicability. The script block will be given identifier id (specified as an
integer, or as a string symbolic name such as "s5"); this may be NULL if there is no need to be
able to refer to the block later. The registered callback is added to the end of the list of registered
SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick
(see section 26.11 for details). The new SLiMEidosBlock will be defined as a global variable
immediately by this method (see section 25.12), and will also be returned by this method.
– (object<SLiMEidosBlock>$)registerSurvivalCallback(Nis$ id, string$ source,
[Nio<Subpopulation>$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])
Register a block of Eidos source code, represented as the string singleton source, as an Eidos
survival() callback in the current simulation (specific to the target species), with optional
subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all
subpopulations) and optional start and end ticks all limiting its applicability. The script block will be
given identifier id (specified as an integer, or as a string symbolic name such as "s5"); this may
be NULL if there is no need to be able to refer to the block later. The registered callback is added to
the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible
to execute in the current tick (see section 26.11 for details). The new SLiMEidosBlock will be
defined as a global variable immediately by this method (see section 25.12), and will also be returned
by this method.
– (void)simulationFinished(void)
Declare the current simulation finished. This method is equivalent to the Community method
simulationFinished(), except that this method is only legal to call in single-species models (to
provide backward compatibility). It is recommended that new code should call the Community
method; this method may be deprecated in the future.
– (void)skipTick(void)
Deactivate the target species for the current tick. This sets the active property of the species to F; it
also set the active property of all callbacks that belong to the species (with the species as their
species specifier) to F, and sets the active property of all events that are synchronized with the
species (with the species as their ticks specifier) to F. The cycle counter for the species will not be
incremented at the end of the tick. This method may only be called in first() events, to ensure that
species are either active or inactive throughout a given tick.
– (object<Mutation>)subsetMutations([No<Mutation>$ exclude = NULL],
[Nio<MutationType>$ mutType = NULL], [Ni$ position = NULL],
[Nis$ nucleotide = NULL], [Ni$ tag = NULL], [Ni$ id = NULL])
Returns a vector of mutations subset from the list of all active mutations in the species (as would be
provided by the mutations property). The parameters specify constraints upon the subset of
mutations that will be returned. Parameter exclude, if non-NULL, may specify a specific mutation that
should not be included (typically the focal mutation in some operation). Parameter mutType, if non-
NULL, may specify a mutation type for the mutations to be returned (as either a MutationType object
or an integer identifier). Parameter position, if non-NULL, may specify a base position for the
mutations to be returned. Parameter nucleotide, if non-NULL, may specify a nucleotide for the
mutations to be returned (either as a string, "A" / "C" / "G" / "T", or as an integer, 0 / 1 / 2 / 3
respectively). Parameter tag, if non-NULL, may specify a tag value for the mutations to be returned.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 727
Parameter id, if non-NULL, may specify a required value for the id property of the mutations to be
returned.
This method is shorthand for getting the mutations property of the subpopulation, and then using
operator [] to select only mutations with the desired properties; besides being much simpler than the
equivalent Eidos code, it is also much faster. Note that if you only need to select on mutation type,
the mutationsOfType() method will be even faster.
– (logical$)treeSeqCoalesced(void)
Returns the coalescence state for the recorded tree sequence at the last simplification. The returned
value is a logical singleton flag, T to indicate that full coalescence was observed at the last treesequence
simplification (meaning that there is a single ancestral individual that roots all ancestry trees
at all sites along the chromosome – although not necessarily the same ancestor at all sites), or F if full
coalescence was not observed. For simple models, reaching coalescence may indicate that the model
has reached an equilibrium state, but this may not be true in models that modify the dynamics of the
model during execution by changing migration rates, introducing new mutations programmatically,
dictating non-random mating, etc., so be careful not to attach more meaning to coalescence than it is
due; some models may require burn-in beyond coalescence to reach equilibrium, or may not have an
equilibrium state at all. Also note that some actions by a model, such as adding a new subpopulation,
may cause the coalescence state to revert from T back to F (at the next simplification), so a return
value of T may not necessarily mean that the model is coalesced at the present moment – only that it
was coalesced at the last simplification.
This method may only be called if tree sequence recording has been turned on with
initializeTreeSeq(); in addition, checkCoalescence=T must have been supplied to
initializeTreeSeq(), so that the necessary work is done during each tree-sequence simplification.
Since this method does not perform coalescence checking itself, but instead simply returns the
coalescence state observed at the last simplification, it may be desirable to call treeSeqSimplify()
immediately before treeSeqCoalesced() to obtain up-to-date information. However, the speed
penalty of doing this in every tick would be large, and most models do not need this level of
precision; usually it is sufficient to know that the model has coalesced, without knowing whether that
happened in the current tick or in a recent preceding tick.
– (void)treeSeqOutput(string$ path, [logical$ simplify = T],
[logical$ includeModel = T], [No$ metadata = NULL])
Outputs the current tree sequence recording tables to the path specified by path. This method may
only be called if tree sequence recording has been turned on with initializeTreeSeq(). If
simplify is T (the default), simplification will be done immediately prior to output; this is almost
always desirable, unless a model wishes to avoid simplification entirely. (Note that if simplification is
not done, then all genomes since the last simplification will be marked as samples in the resulting tree
sequence.) A binary tree sequence file will be written to the specified path; a filename extension
of .trees is suggested for this type of file.
Normally, the full SLiM script used to generate the tree sequence is written out to the provenance
entry of the tree sequence file, to the model subkey of the parameters top-level key. Supplying F for
includeModel suppresses output of the full script; see section 27.4.6 for further discussion.
A Dictionary object containing user-generated metadata may be supplied with the metadata
parameter. If present, this dictionary will be serialized as JSON and attached to the saved tree
sequence under a key named user_metadata, within the SLiM key (see section 27.4.5). If tskit is
used to read the tree sequence in Python, this metadata will automatically be deserialized and made
available at ts.metadata["SLiM"]["user_metadata"]. This metadata dictionary is not used by
SLiM, or by pyslim, tskit, or msprime; you may use it for any purpose you wish. Note that
metadata may actually be any subclass of Dictionary, such as a DataFrame. It can even be a
Species object such as sim, or a LogFile instance; however, only the keys and values contained by
the object’s Dictionary superclass state will be serialized into the metadata (properties of the
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 728
subclass will be ignored). This metadata dictionary can be recovered from the saved file using the
treeSeqMetadata() function.
– (void)treeSeqRememberIndividuals(object<Individual> individuals,
[logical$ permanent = T])
Mark the individuals specified by individuals to be kept across tree sequence table simplification.
This method may only be called if tree sequence recording has been turned on with
initializeTreeSeq(). All currently living individuals are always kept across simplification; this
method does not need to be called, and indeed should not be called, for that purpose. Instead,
treeSeqRememberIndividuals() allows any individual, including dead individuals, to be kept in
the final tree sequence. Typically this would be used, for example, to keep particular individuals that
you wanted to be able to trace ancestry back to in later analysis. However, this is not the typical
usage pattern for tree sequence recording; most models will not need to call this method.
There are two ways to keep individuals across simplification. If permanent is T (the default), then the
specified individuals will be permanently remembered: their genomes will be added to the current
sample, and they will always be present in the tree sequence. Permanently remembering a large
number of individuals will, of course, markedly increase memory usage and runtime.
Supplying F for permanent will instead mark the individuals only for (temporary) retention: their
genomes will not be added to the sample, and they will appear in the final tree sequence only if one
of their genomes is retained across simplification. In other words, the rule of thumb for retained
individuals is simple: if a genome is kept by simplification, the genome’s corresponding individual is
kept also, if it is retained. Note that permanent remembering takes priority; calling this function with
permanent=F on an individual that has previously been permanently remembered will not remove it
from the sample.
The behavior of simplification for individuals retained with permanent=F depends upon the value of
the retainCoalescentOnly flag passed to initializeTreeSeq(); here we will discuss the behavior
of that flag in detail. First of all, genomes are always removed by simplification unless they are (a) part
of the final generation (i.e., in a living individual when simplification occurs), (b) ancestral to the final
generation, (c) a genome of a permanently remembered individual, or (d) ancestral to a permanently
remembered individual. If retainCoalescentOnly is T (the default), they are also always removed if
they are not a branch point (i.e., a coalescent node or most recent common ancestor) in the tree
sequence. In some cases it may be useful to retain a genome and its associated individual when it is
simply an intermediate node in the ancestry (i.e., in the middle of a branch). This can be enabled by
setting retainCoalescentOnly to F in your call to initializeTreeSeq(). In this case, ancestral
genomes that are intermediate (“unary nodes”, in tskit parlance) and are within an individual that
has been retained using the permanent=F flag here are kept, along with the retained individual itself.
Since setting retainCoalescentOnly to F will prevent the unary nodes for retained individuals from
being pruned, simplification may often be unable to prune very much at all from the tree sequence,
and memory usage and runtime may increase rapidly. If you are retaining many individuals, this
setting should therefore be used only with caution; it is not necessary if you are purely interested in
the most recent common ancestors. See the pyslim documentation for further discussion of retaining
and remembering individuals and the effects of the retainCoalescentOnly flag.
The metadata (age, location, etc) that are stored in the resulting tree sequence are those values present
at either (a) the final generation, if the individual is alive when the tree sequence is output, or (b) the
last time that the individual was remembered, if not. Calling treeSeqRememberIndividuals() on
an individual that is already remembered will cause the archived information about the remembered
individual to be updated to reflect the individual’s current state; care should be taken to remember
individuals at a point in time when their state is valid. A case where this is particularly important is for
the spatial location of individuals in continuous-space models. SLiM automatically retains the
portions of the genomes that comprise the first generation of any new subpopulation created with
addSubpop() that are inherited by extant individuals, for easy recapitation and other analysis (see
sections 17.2 and 17.10). However, the individuals of the first generation are not remembered
automatically, only their needed genomic information.
TOC I TOC II WF nonWF initialize() Community Genome Individual LogFile Mutation Species Subpopulation
events mutationEffect() interaction() mateChoice() modifyChild() mutation() recombination() reproduction() survival() 729
– (void)treeSeqSimplify(void)
Triggers an immediate simplification of the tree sequence recording tables. This method may only be
called if tree sequence recording has been turned on with initializeTreeSeq(). A call to this
method will free up memory being used by entries that are no longer in the ancestral path of any
individual within the current sample (currently living individuals, in other words, plus those explicitly
added to the sample with treeSeqRememberIndividuals()), but it can also take a significant
amount of time. Typically calling this method is not necessary; the automatic simplification performed
occasionally by SLiM should be sufficient for most models.
