% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slim_lang.R
\name{addRecombinant}
\alias{addRecombinant}
\alias{Subpopulation$addRecombinant}
\alias{.P$addRecombinant}
\title{SLiM method addRecombinant}
\usage{
addRecombinant(strand1, strand2, breaks1, strand3, strand4, breaks2, sex)
}
\arguments{
\item{strand1}{An object of type null or Genome object. Must be of length 1 (a
singleton). See details for description.}

\item{strand2}{An object of type null or Genome object. Must be of length 1 (a
singleton). See details for description.}

\item{breaks1}{An object of type null or integer. See details for description.}

\item{strand3}{An object of type null or Genome object. Must be of length 1 (a
singleton). See details for description.}

\item{strand4}{An object of type null or Genome object. Must be of length 1 (a
singleton). See details for description.}

\item{breaks2}{An object of type null or integer. See details for description.}

\item{sex}{An object of type null or float or string. Must be of length 1 (a
singleton). The default value is \code{NULL}. See details for description.}
}
\value{
An object of type null or Individual object. Return will be of length 1
(a singleton)
}
\description{
Documentation for SLiM function \code{addRecombinant}, which is a method of the
SLiM class \code{Subpopulation}.
Note that the R function is a stub, it does not do anything in R (except bring
up this documentation). It will only do
anything useful when used inside a \code{\link{slim_block}} function further
nested in a \code{\link{slim_script}}
function call, where it will be translated into valid SLiM code as part of a
full SLiM script.
}
\details{
Generates a new offspring individual from the given parental genomes
with the specified crossover breakpoints, queues it for addition to the target
subpopulation, and returns it. The new offspring will not be visible as a
member of the target subpopulation until the end of the offspring generation
life cycle stage. The target subpopulation will be used to locate applicable
mutation() and modifyChild() callbacks governing the generation of the offspring
individual (unlike the other addX() methods, because there are potentially up
to four parental individuals to reference); recombination() callbacks will not
be called by this method. This method is an advanced feature; most models will
use addCrossed(), addSelfed(), or addCloned() instead. This method supports
several possible configurations for strand1, strand2, and breaks1 (and the same
applies for strand3, strand4, and breaks2). If strand1 and strand2 are both
NULL, the corresponding genome in the generated offspring will be empty, as
from addEmpty(), with no parental genomes and no added mutations; in this case,
breaks1 must be NULL or zero-length. If strand1 is non-NULL but strand2 is NULL,
the corresponding genome in the generated offspring will be a clonal copy of
strand1 with mutations added, as from addCloned(); in this case, breaks1 must
similarly be NULL or zero-length. If strand1 and strand2 are both non-NULL, the
corresponding genome in the generated offspring will result from recombination
between strand1 and strand2 with mutations added, as from addCrossed(), with
strand1 being the initial copy strand; copying will switch between strands at
each breakpoint in breaks1, which must be non-NULL but need not be sorted or
uniqued (SLiM will sort and unique the supplied breakpoints internally). (It is
not currently legal for strand1 to be NULL and strand2 non-NULL; that variant
may be assigned some meaning in future.) Again, this discussion applies equally
to strand3, strand4, and breaks2, mutatis mutandis. Note that when new mutations
are generated by addRecombinant(), their subpopID property will be the id of
the offspring’s subpopulation, since the parental subpopulation is ambiguous
in the general case; this behavior differs from the other add...() methods.
The sex parameter is interpreted exactly as in addCrossed(); see that method
for discussion. If the offspring sex is specified in any way (i.e., if sex is
non-NULL), the strands provided must be compatible with the sex chosen. If the
offspring sex is not specified (i.e., if sex is NULL), the sex will be inferred
from the strands provided where possible (when modeling an X or Y chromosome),
or will be chosen randomly otherwise (when modeling autosomes); it will not be
inferred from the sex of the individuals possessing the parental strands, even
when the reproductive mode is essentially clonal from a single parent, since
such inference would be ambiguous in the general case. Similarly, the offspring
is considered to have no parents for the purposes of pedigree tracking, since
there may be more than two "parents” in the general case. When modeling the X or
Y, strand1 and strand2 must be X genomes (or NULL), and strand3 and strand4 must
both be X genomes or both be Y genomes (or NULL). These semantics allow several
uses for addRecombinant(). When all strands are non-NULL, it is similar to
addCrossed() except that the recombination breakpoints are specified explicitly,
allowing very precise offspring generation without having to override SLiM’s
breakpoint generation with a recombination() callback. When only strand1 and
strand3 are supplied, it is very similar to addCloned(), creating a clonal
offspring, except that the two parental genomes need not belong to the same
individual (whatever that might mean biologically). Supplying only strand1 is
useful for modeling clonally reproducing haploids; the second genome of every
offspring will be kept empty and will not receive new mutations. For a model
of clonally reproducing haploids that undergo horizontal gene transfer (HGT),
supplying only strand1 and strand2 will allow HGT from strand2 to replace
segments of an otherwise clonal copy of strand1, while the second genome of the
generated offspring will again be kept empty; this could be useful for modeling
bacterial conjugation, for example. Other variations are also possible. Note
that gene conversion tracts are not explicitly supported by this method; the
breaks vectors provide crossover breakpoints, which may be used to implement
crossovers or simple gene conversion tracts. There is no way to specify complex
gene conversion tracts with heteroduplex mismatch repair. Note that this method
is only for use in nonWF models. See addCrossed() for further general notes on
the addition of new offspring individuals.
}
\section{Copyright}{

This is documentation for a function in the SLiM software, and has been
reproduced from the official manual,
which can be found here: \url{http://benhaller.com/slim/SLiM_Manual.pdf}. This
documentation is
Copyright © 2016–2020 Philipp Messer. All rights reserved. More information
about SLiM can be found
on the official website: \url{https://messerlab.org/slim/}
}

\author{
Benjamin C Haller (\email{bhaller@benhaller.com}) and Philipp W Messer
(\email{messer@cornell.edu})
}
