% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slim_lang.R
\name{clippedIntegral}
\alias{clippedIntegral}
\alias{InteractionType$clippedIntegral}
\alias{.IT$clippedIntegral}
\title{SLiM method clippedIntegral}
\usage{
clippedIntegral(receivers)
}
\arguments{
\item{receivers}{An object of type null or Individual object. See details for
description.}
}
\value{
An object of type float.
}
\description{
Documentation for SLiM function \code{clippedIntegral}, which is a method of the
SLiM class \code{\link{InteractionType}}.
Note that the R function is a stub, it does not do anything in R (except bring
up this documentation). It will only do
anything useful when used inside a \code{\link{slim_block}} function further
nested in a \code{\link{slim_script}}
function call, where it will be translated into valid SLiM code as part of a
full SLiM script.
}
\details{
Documentation for this function can be found in the official
\href{http://benhaller.com/slim/SLiM_Manual.pdf#page=691}{SLiM manual: page
691}.

Returns a vector containing the integral of the interaction function as
experienced by each of the individuals in receivers. For each given individual,
the interaction function is clipped to the edges of the spatial bounds of the
subpopulation that individual inhabits; the individual's spatial position must
be within bounds or an error is raised. A periodic boundary will, correctly,
not clip the interaction function. The interaction function is also clipped
to the interaction's maximum distance; that distance must be less than half
of the extent of the spatial bounds in each dimension (so that, for a given
dimension, the interaction function is clipped by the spatial bounds on only
one side), otherwise an error is raised. Note that receiver constraints are
not applied; an individual might not actually receive any interactions because
of those constraints, but it is still considered to have the same interaction
function integral. If receivers is NULL, the maximal integral is returned,
as would be experienced by an individual farther than the maximum distance
from any edge. The evaluate() method must have been previously called for the
receiver subpopulation, and positions saved at evaluation time will be used.
If the InteractionType is non-spatial, this method may not be called. The
computed value of the integral is not exact; it is calculated by an approximate
numerical method designed to be fast, but the error should be fairly small
(typically less than 1% from the true value). A large amount of computation will
occur the first time this method is called (perhaps taking more than a second,
depending upon hardware), but subsequent calls should be very fast. This method
does not invoke interaction() callbacks; the calculated integrals are only for
the interaction function itself, and so will not be accurate if interaction()
callbacks modify the relationship between distance and interaction strength. For
this reason, the overhead of the first call will not reoccur when individuals
move or when the interaction is re-evaluated; for typical models, the initial
overhead will be incurred only once. The initial overhead will reoccur, however,
if the interaction function itself, or the maximum interaction distance, are
changed; frequent change of those parameters may render the performance of
this method unacceptable. The integral values returned by clippedIntegral() can
be useful for computing interaction metrics that are scaled by the amount of
"interaction field" (to coin a term) that is present for a given individual,
producing metrics of interaction density. Notably, the localPopulationDensity()
method automatically incorporates the mechanics of clippedIntegral() into
the calculations it performs; see that method's documentation for further
discussion of this concept. This approach can also be useful with the
interactingNeighborCount() method, provided that the interaction function is of
type "f" (since the neighbor count does not depend upon interaction strength).
}
\section{Copyright}{

This is documentation for a function in the SLiM software, and has been
reproduced from the official manual,
which can be found here: \url{http://benhaller.com/slim/SLiM_Manual.pdf}. This
documentation is
Copyright Â© 2016-2020 Philipp Messer. All rights reserved. More information
about SLiM can be found
on the official website: \url{https://messerlab.org/slim/}
}

\seealso{
Other InteractionType: 
\code{\link{IT}},
\code{\link{distance}()},
\code{\link{distanceFromPoint}()},
\code{\link{drawByStrength}()},
\code{\link{evaluate}()},
\code{\link{interactingNeighborCount}()},
\code{\link{interactionDistance}()},
\code{\link{localPopulationDensity}()},
\code{\link{nearestInteractingNeighbors}()},
\code{\link{nearestNeighbors}()},
\code{\link{nearestNeighborsOfPoint}()},
\code{\link{neighborCount}()},
\code{\link{neighborCountOfPoint}()},
\code{\link{setConstraints}()},
\code{\link{setInteractionFunction}()},
\code{\link{strength}()},
\code{\link{testConstraints}()},
\code{\link{totalOfNeighborStrengths}()},
\code{\link{unevaluate}()}
}
\author{
Benjamin C Haller (\email{bhaller@benhaller.com}) and Philipp W Messer
(\email{messer@cornell.edu})
}
\concept{InteractionType}
