% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slim_lang.R
\name{eidos_apply}
\alias{eidos_apply}
\alias{Eidos$apply}
\alias{.E$apply}
\title{Eidos method apply}
\usage{
eidos_apply(x, margin, lambdaSource)
}
\arguments{
\item{x}{An object of type any or integer or string. See details for
description.}

\item{margin}{An object of type any or integer or string. See details for
description.}

\item{lambdaSource}{An object of type any or integer or string. Must be of
length 1 (a singleton). See details for description.}
}
\value{
An object of type any.
}
\description{
Documentation for Eidos function \code{apply}, which is a method of
\code{\link{Eidos}}.
Note that the R function is a stub, it does not do anything in R (except bring
up this documentation). It will only do
anything useful when used inside a \code{\link{slim_block}} function further
nested in a \code{\link{slim_script}}
function call, where it will be translated into valid SLiM code as part of a
full SLiM script.
}
\details{
Documentation for this function can be found in the official
\href{http://benhaller.com/slim/SLiM_Manual.pdf#page=NA}{SLiM manual: page NA}.

Prior to Eidos 1.6 / SLiM 2.6, sapply() was named apply(), and this
function did not yet exist Applies a block of Eidos code to margins of x. This
function is essentially an extension of sapply() for use with matrices and
arrays; it is recommended that you fully understand sapply() before tackling
this function. As with sapply(), the lambda specified by lambdaSource will
be executed for subsets of x, and the results will be concatenated together
with type-promotion in the style of c() to produce a result. Unlike sapply(),
however, the subsets of x used might be rows, columns, or higher-dimensional
slices of x, rather than just single elements, depending upon the value of
margin. For apply(), x must be a matrix or array (see section 2.9). The apply()
function in Eidos is patterned directly after the apply() function in R, and
should behave identically, except that dimension indices in Eidos are zero-based
whereas in R they are one-based. The margin parameter gives the indices of
dimensions of x that will be iterated over when assembling values to supply to
lambdaSource. If x is a matrix it has two dimensions: rows, of dimension index
0, and columns, of dimension index 1. These are the indices of the dimension
sizes returned by dim(); dim(x)[0] gives the number of rows of x, and dim(x)[1]
gives the number of columns. These dimension indices are also apparent when
subsetting x; a subset index in position 0, such as x[m,], gives row m of x,
whereas a subset index in position 1, such as x[,n], gives column n of x. In the
same manner, supplying 0 for margin specifies that subsets of x from x[0,] to
x[m,] should be "passed" to lambdaSource, through the applyValue "parameter";
dimension 0 is iterated over, whereas dimension 1 is taken in aggregate since
it is not included in margin. The final effect of this is that whole rows of
x are passed to lambdaSource through applyValue. Similarly, margin=1 would
specify that subsets of x from x[,0] to x[,n] should be passed to lambdaSource,
resulting in whole 70 columns being passed. Specifying margin=c(0,1) would
indicate that dimensions 0 and 1 should both be iterated over (dimension 0
more rapidly), so for a matrix each each individual value of x would be passed
to lambdaSource. Specifying margin=c(1,0) would similarly iterate over both
dimensions, but dimension 1 more rapidly; the traversal order would therefore
be different, and the dimensionality of the result would also differ (see
below). For higher-dimensional arrays dimension indices beyond 1 exist, and so
margin=c(0,1) or margin=c(1,0) would provide slices of x to lambdaSource, each
slice having a specific row and column index. Slices are generated by subsetting
in the same way as operator [], but additionally, redundant dimensions are
dropped as by drop(). The return value from apply() is built up from the
type-promoted concatenated results, as if by the c() function, from the iterated
execution of lambdaSource; the only question is what dimensional structure is
imposed upon that vector of values. If the results from lambdaSource are not of
a consistent length, or are of length zero, then the concatenated results are
returned as a plain vector. If all results are of length n > 1, the return value
is an array of dimensions c(n, dim(x)[margin]); in other words, each n-vector
provides the lowest dimension of the result, and the sizes of the marginal
dimensions are imposed upon the data above that. If all results are of length
n == 1, then if a single margin was specified the result is a vector (of length
equal to the size of that marginal dimension), or if more than one margin was
specified the result is an array of dimension dim(x)[margin]; in other words,
the sizes of the marginal dimensions are imposed upon the data. Since apply()
iterates over the marginal dimensions in the same manner, these structures
follows the structure of the data. The above explanation may not be entirely
clear, so let's look at an example. If x is a matrix with two rows and three
columns, such as defined by x = matrix(1:6, nrow=2);, then executing apply(x,
0, "sum(applyValue);"); would cause each row of x to be supplied to the lambda
through applyValue, and the values in each row would thus be summed to produce
9 12 as a result. The call apply(x, 1, "sum(applyValue);"); would instead sum
columns of x, producing 3 7 11 as a result. Now consider using range() rather
than sum() in the lambda, thus producing two values for each row or column. The
call apply(x, 0, "range(applyValue);"); produces a result of matrix(c(1,5,2,6),
nrow=2), with the range of the first row of x, 1-5, in the first column of
the result, and the range of the second row of x, 2-6, in the second column.
Although visualization becomes more difficult, these same patterns extend to
higher dimensions and arbitrary margins of x.
}
\section{Copyright}{

This is documentation for a function in the SLiM software, and has been
reproduced from the official manual,
which can be found here: \url{http://benhaller.com/slim/SLiM_Manual.pdf}. This
documentation is
Copyright Â© 2016-2020 Philipp Messer. All rights reserved. More information
about SLiM can be found
on the official website: \url{https://messerlab.org/slim/}
}

\seealso{
Other Eidos: 
\code{\link{E}},
\code{\link{eidos_abs}()},
\code{\link{eidos_acos}()},
\code{\link{eidos_all}()},
\code{\link{eidos_any}()},
\code{\link{eidos_array}()},
\code{\link{eidos_asFloat}()},
\code{\link{eidos_asInteger}()},
\code{\link{eidos_asLogical}()},
\code{\link{eidos_asString}()},
\code{\link{eidos_asin}()},
\code{\link{eidos_assert}()},
\code{\link{eidos_atan}()},
\code{\link{eidos_atan2}()},
\code{\link{eidos_beep}()},
\code{\link{eidos_c}()},
\code{\link{eidos_cat}()},
\code{\link{eidos_catn}()},
\code{\link{eidos_cbind}()},
\code{\link{eidos_ceil}()},
\code{\link{eidos_citation}()},
\code{\link{eidos_clock}()},
\code{\link{eidos_cmColors}()},
\code{\link{eidos_color2rgb}()},
\code{\link{eidos_colors}()},
\code{\link{eidos_cor}()},
\code{\link{eidos_cos}()},
\code{\link{eidos_cov}()},
\code{\link{eidos_createDirectory}()},
\code{\link{eidos_cumProduct}()},
\code{\link{eidos_cumSum}()},
\code{\link{eidos_date}()},
\code{\link{eidos_dbeta}()},
\code{\link{eidos_debugIndent}()},
\code{\link{eidos_defineConstant}()},
\code{\link{eidos_defineGlobal}()},
\code{\link{eidos_deleteFile}()},
\code{\link{eidos_dexp}()},
\code{\link{eidos_dgamma}()},
\code{\link{eidos_diag}()},
\code{\link{eidos_dim}()},
\code{\link{eidos_dmvnorm}()},
\code{\link{eidos_dnorm}()},
\code{\link{eidos_drop}()},
\code{\link{eidos_elementType}()},
\code{\link{eidos_exists}()},
\code{\link{eidos_exp}()},
\code{\link{eidos_fileExists}()},
\code{\link{eidos_filesAtPath}()},
\code{\link{eidos_findInterval}()},
\code{\link{eidos_float}()},
\code{\link{eidos_floor}()},
\code{\link{eidos_flushFile}()},
\code{\link{eidos_format}()},
\code{\link{eidos_functionSignature}()},
\code{\link{eidos_functionSource}()},
\code{\link{eidos_getSeed}()},
\code{\link{eidos_getwd}()},
\code{\link{eidos_heatColors}()},
\code{\link{eidos_hsv2rgb}()},
\code{\link{eidos_identical}()},
\code{\link{eidos_ifelse}()},
\code{\link{eidos_integer}()},
\code{\link{eidos_integerDiv}()},
\code{\link{eidos_integerMod}()},
\code{\link{eidos_isFinite}()},
\code{\link{eidos_isFloat}()},
\code{\link{eidos_isInfinite}()},
\code{\link{eidos_isInteger}()},
\code{\link{eidos_isLogical}()},
\code{\link{eidos_isNAN}()},
\code{\link{eidos_isNULL}()},
\code{\link{eidos_isObject}()},
\code{\link{eidos_isString}()},
\code{\link{eidos_length}()},
\code{\link{eidos_license}()},
\code{\link{eidos_log}()},
\code{\link{eidos_log10}()},
\code{\link{eidos_log2}()},
\code{\link{eidos_logical}()},
\code{\link{eidos_lowerTri}()},
\code{\link{eidos_ls}()},
\code{\link{eidos_match}()},
\code{\link{eidos_matrix}()},
\code{\link{eidos_matrixMult}()},
\code{\link{eidos_max}()},
\code{\link{eidos_mean}()},
\code{\link{eidos_min}()},
\code{\link{eidos_nchar}()},
\code{\link{eidos_ncol}()},
\code{\link{eidos_nrow}()},
\code{\link{eidos_object}()},
\code{\link{eidos_order}()},
\code{\link{eidos_paste}()},
\code{\link{eidos_paste0}()},
\code{\link{eidos_pmax}()},
\code{\link{eidos_pmin}()},
\code{\link{eidos_pnorm}()},
\code{\link{eidos_print}()},
\code{\link{eidos_product}()},
\code{\link{eidos_qnorm}()},
\code{\link{eidos_quantile}()},
\code{\link{eidos_rainbow}()},
\code{\link{eidos_range}()},
\code{\link{eidos_rank}()},
\code{\link{eidos_rbeta}()},
\code{\link{eidos_rbind}()},
\code{\link{eidos_rbinom}()},
\code{\link{eidos_rcauchy}()},
\code{\link{eidos_rdunif}()},
\code{\link{eidos_readCSV}()},
\code{\link{eidos_readFile}()},
\code{\link{eidos_rep}()},
\code{\link{eidos_repEach}()},
\code{\link{eidos_rev}()},
\code{\link{eidos_rexp}()},
\code{\link{eidos_rf}()},
\code{\link{eidos_rgamma}()},
\code{\link{eidos_rgb2color}()},
\code{\link{eidos_rgb2hsv}()},
\code{\link{eidos_rgeom}()},
\code{\link{eidos_rlnorm}()},
\code{\link{eidos_rm}()},
\code{\link{eidos_rmvnorm}()},
\code{\link{eidos_rnbinom}()},
\code{\link{eidos_rnorm}()},
\code{\link{eidos_round}()},
\code{\link{eidos_rpois}()},
\code{\link{eidos_runif}()},
\code{\link{eidos_rweibull}()},
\code{\link{eidos_sample}()},
\code{\link{eidos_sapply}()},
\code{\link{eidos_sd}()},
\code{\link{eidos_seq}()},
\code{\link{eidos_seqAlong}()},
\code{\link{eidos_seqLen}()},
\code{\link{eidos_setDifference}()},
\code{\link{eidos_setIntersection}()},
\code{\link{eidos_setSeed}()},
\code{\link{eidos_setSymmetricDifference}()},
\code{\link{eidos_setUnion}()},
\code{\link{eidos_setwd}()},
\code{\link{eidos_sin}()},
\code{\link{eidos_size}()},
\code{\link{eidos_sort}()},
\code{\link{eidos_sortBy}()},
\code{\link{eidos_source}()},
\code{\link{eidos_sqrt}()},
\code{\link{eidos_stop}()},
\code{\link{eidos_str}()},
\code{\link{eidos_strcontains}()},
\code{\link{eidos_strfind}()},
\code{\link{eidos_string}()},
\code{\link{eidos_strprefix}()},
\code{\link{eidos_strsplit}()},
\code{\link{eidos_strsuffix}()},
\code{\link{eidos_substr}()},
\code{\link{eidos_sum}()},
\code{\link{eidos_sumExact}()},
\code{\link{eidos_suppressWarnings}()},
\code{\link{eidos_sysinfo}()},
\code{\link{eidos_system}()},
\code{\link{eidos_t}()},
\code{\link{eidos_tabulate}()},
\code{\link{eidos_tan}()},
\code{\link{eidos_tempdir}()},
\code{\link{eidos_terrainColors}()},
\code{\link{eidos_time}()},
\code{\link{eidos_trunc}()},
\code{\link{eidos_ttest}()},
\code{\link{eidos_type}()},
\code{\link{eidos_unique}()},
\code{\link{eidos_upperTri}()},
\code{\link{eidos_usage}()},
\code{\link{eidos_var}()},
\code{\link{eidos_version}()},
\code{\link{eidos_which}()},
\code{\link{eidos_whichMax}()},
\code{\link{eidos_whichMin}()},
\code{\link{eidos_writeFile}()},
\code{\link{eidos_writeTempFile}()}
}
\author{
Benjamin C Haller (\email{bhaller@benhaller.com}) and Philipp W Messer
(\email{messer@cornell.edu})
}
\concept{Eidos}
