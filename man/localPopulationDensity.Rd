% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slim_lang.R
\name{localPopulationDensity}
\alias{localPopulationDensity}
\alias{InteractionType$localPopulationDensity}
\alias{.IT$localPopulationDensity}
\title{SLiM method localPopulationDensity}
\usage{
localPopulationDensity(receivers, exerterSubpop)
}
\arguments{
\item{receivers}{An object of type Individual object. See details for
description.}

\item{exerterSubpop}{An object of type null or Subpopulation object. Must be
of length 1 (a singleton). The default value is \code{NULL}. See details for
description.}
}
\value{
An object of type float.
}
\description{
Documentation for SLiM function \code{localPopulationDensity}, which is a method
of the SLiM class \code{\link{InteractionType}}.
Note that the R function is a stub, it does not do anything in R (except bring
up this documentation). It will only do
anything useful when used inside a \code{\link{slim_block}} function further
nested in a \code{\link{slim_script}}
function call, where it will be translated into valid SLiM code as part of a
full SLiM script.
}
\details{
Documentation for this function can be found in the official
\href{http://benhaller.com/slim/SLiM_Manual.pdf#page=694}{SLiM manual: page
694}.

Returns a vector of the local population density present at the
location of each individual in receivers, which does not need to be a singleton;
indeed, it can be a vector of all of the individuals in a given subpopulation.
However, all receivers must be in the same subpopulation. The local population
density is computed from exerters in exerterSubpop, or if that is NULL (the
default), then from the receiver's subpopulation. The evaluate() method must
have been previously called for the receiver and exerter subpopulations, and
positions saved at evaluation time will be used. Population density is estimated
using interaction strengths, effectively doing a kernel density estimate using
the interaction function as the kernel. What is returned is computed as the
total interaction strength present at a given point, divided by the integral
of the interaction function around that point after clipping by the spatial
bounds of the exerter subpopulation (what one might think of as the amount
of "interaction field" around the point). This provides an estimate of local
population density, in units of individuals per unit area, as a weighted
average over the area covered by the interaction function, where the weight of
each exerter in the average is the value of the interaction function at that
exerter's position. This can also be thought of as a measure of the amount of
interaction happening per unit of interaction field in the space surrounding
the point. To calculate the clipped integral of the interaction function,
this method uses the same numerical estimator used by the clippedIntegral()
method of InteractionType, and all of the caveats described for that method
apply here also; notably, all individuals must be within spatial bounds,
the maximum interaction distance must be less than half the spatial extent
of the subpopulation, and interaction() callbacks are not used (and so,
for this method, are not allowed to be active). See the documentation for
clippedIntegral() for further discussion of the details of these calculations.
To calculate the total interaction strength around the position of a receiver,
this method uses the same machinery as the totalOfNeighborStrengths() method
of InteractionType, except that - in contrast to other InteractionType methods
- the interaction strength exerted by the receiver itself is included in the
total (if the exerter subpopulation is the receiver's own subpopulation). This
is because population density at the location of an individual includes the
individual itself. If this is not desirable, the totalOfNeighborStrengths()
method should probably be used. To see the point of this method, consider a
receiver located near the edge of the spatial bounds of its subpopulation.
Some portion of the interaction function that surrounds that receiver falls
outside the spatial bounds of its subpopulation, and will therefore never
contain an interacting exerter. If, for example, interaction strengths are used
as a measure of competition, this receiver will therefore have an advantage,
because it will never feel any competition from the portion of its range that
falls outside spatial bounds. However, that portion of its range is presumably
also not available to the receiver itself, for foraging or hunting, in which
case this advantage is not biologically realistic, but is instead just an
undesirable "edge effect" artifact. Dividing by the integral of the interaction
function, clipped to the spatial bounds, provides a way to compensate for this
edge effect. A nice side effect of using local population densities instead
of total interaction strengths is that the maximum interaction strength passed
to setInteractionFunction() no longer matters; it cancels out when the total
interaction strength is divided by the receiver's clipped integral. However, the
shape of the interaction function does still matter; it determines the relative
weights used for exerters at different distances from the position of the
receiver.
}
\section{Copyright}{

This is documentation for a function in the SLiM software, and has been
reproduced from the official manual,
which can be found here: \url{http://benhaller.com/slim/SLiM_Manual.pdf}. This
documentation is
Copyright Â© 2016-2020 Philipp Messer. All rights reserved. More information
about SLiM can be found
on the official website: \url{https://messerlab.org/slim/}
}

\seealso{
Other InteractionType: 
\code{\link{IT}},
\code{\link{clippedIntegral}()},
\code{\link{distance}()},
\code{\link{distanceFromPoint}()},
\code{\link{drawByStrength}()},
\code{\link{evaluate}()},
\code{\link{interactingNeighborCount}()},
\code{\link{interactionDistance}()},
\code{\link{nearestInteractingNeighbors}()},
\code{\link{nearestNeighbors}()},
\code{\link{nearestNeighborsOfPoint}()},
\code{\link{neighborCount}()},
\code{\link{neighborCountOfPoint}()},
\code{\link{setConstraints}()},
\code{\link{setInteractionFunction}()},
\code{\link{strength}()},
\code{\link{testConstraints}()},
\code{\link{totalOfNeighborStrengths}()},
\code{\link{unevaluate}()}
}
\author{
Benjamin C Haller (\email{bhaller@benhaller.com}) and Philipp W Messer
(\email{messer@cornell.edu})
}
\concept{InteractionType}
