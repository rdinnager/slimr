% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slimr_output.R
\name{r_output}
\alias{r_output}
\alias{slimr_output}
\title{Tell SLiM to produce easily parseable output}
\usage{
r_output(
  slimr_expr,
  name,
  do_every = 1,
  type = NULL,
  expression = NULL,
  time_counter = community.tick
)

slimr_output(
  slimr_expr,
  name,
  do_every = 1,
  type = NULL,
  expression = NULL,
  time_counter = community.tick
)
}
\arguments{
\item{slimr_expr}{A SLiM expression to generate output. This can either be
a SLiM expression designed to create output, such as \code{outputFull()},
or an object created in the SLiM code, in which case \code{r_output}
will automatically concatenate it to a string and output it}

\item{name}{The name to use to identify this output.}

\item{do_every}{How often should the output be produced? Expressed
as an integer saying how many generations to run before producing output.
e.g. \code{do_every = 10} means to output every 10 generations of the
simulation.}

\item{type}{Provide a custom type to the output. Used mostly for internal purposes.}

\item{expression}{Provide a custom expression to be included with the output.
Used mostly for internal purposes.}

\item{time_counter}{Expression used to extract the simulation time from SLiM. By default this
uses the global timing mechanism in SLiM version >4.0: `community.tick`. For versions <4.0,
use `sim.generation` instead (this parameter is for backwards compatibility with old SLiM versions)}
}
\value{
A placemarker expression that is used by `slimr`internally.
}
\description{
Use this function in a \code{\link{slim_block}} call and it will be
converted in the SLiM script into code to make formatted output.
This output can easily be read into R and even dynamically read
during simulation runs with \code{\link[slimr]{slim_run}} from the
\code{slimr} package. This function should generally only be
used within a \code{\link{slim_block}} call
}
\examples{
if(slim_is_avail()) {
slim_script(
  slim_block(initialize(),
             {
               initializeMutationRate(1e-7);
               initializeMutationType("m1", 0.5, "f", 0.0);
               initializeGenomicElementType("g1", m1, 1.0);
               initializeGenomicElement(g1, 0, 99999);
               initializeRecombinationRate(1e-8);
             }),
  slim_block(1,
             {
               sim.addSubpop("p1", 100);
             }),
  slim_block(100,
             {
               r_output(p1.outputVCFSample(sampleSize = 10), name = "VCF");
               sim.simulationFinished();
             })
) \%>\%
slim_run() -> run_w_out

cat(run_w_out$output_data$data[[1]])
}
}
